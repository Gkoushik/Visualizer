(this.webpackJsonpvisulaizer=this.webpackJsonpvisulaizer||[]).push([[0],{252:function(e,t,n){"use strict";n.r(t);var a=n(0),r=n.n(a),i=n(24),o=n.n(i),s=(n(41),n(2)),l=n(3),c=n(5),u=n(4),d=(n(42),n(16)),p=(n(43),function(e){Object(c.a)(n,e);var t=Object(u.a)(n);function n(){return Object(s.a)(this,n),t.apply(this,arguments)}return Object(l.a)(n,[{key:"render",value:function(){var e=this.props,t=e.col,n=e.isFinish,a=e.isStart,i=e.isWall,o=e.onMouseDown,s=e.onMouseEnter,l=e.onMouseUp,c=e.row,u=e.isVisitednode,d=e.isShortestPath,p=n?"node-finish":a?"node-start":i?"node-wall":d?"node-shortest-path":u?"node-visited":"";return r.a.createElement("div",{id:"node-".concat(c,"-").concat(t),className:"node ".concat(p,"  "),onMouseDown:function(){return o(c,t)},onMouseEnter:function(){return s(c,t)},onMouseUp:function(){return l()}})}}]),n}(a.Component)),h=n(20);function m(e,t,n){var a=[];t.distance=0;for(var r=function(e){var t,n=[],a=Object(h.a)(e);try{for(a.s();!(t=a.n()).done;){var r,i=t.value,o=Object(h.a)(i);try{for(o.s();!(r=o.n()).done;){var s=r.value;n.push(s)}}catch(l){o.e(l)}finally{o.f()}}}catch(l){a.e(l)}finally{a.f()}return n}(e);r.length;){f(r);var i=r.shift();if(!i.isWall){if(i.distance===1/0)return a;if(i.isVisited=!0,a.push(i),i===n)return a;g(i,e)}}}function f(e){e.sort((function(e,t){return e.distance-t.distance}))}function g(e,t){var n,a=function(e,t){var n=[],a=e.col,r=e.row;r>0&&n.push(t[r-1][a]);r<t.length-1&&n.push(t[r+1][a]);a>0&&n.push(t[r][a-1]);a<t[0].length-1&&n.push(t[r][a+1]);return n.filter((function(e){return!e.isVisited}))}(e,t),r=Object(h.a)(a);try{for(r.s();!(n=r.n()).done;){var i=n.value;i.distance=e.distance+1,i.previousNode=e}}catch(o){r.e(o)}finally{r.f()}}function v(e,t,n){var a=new b;a.enqueue(t),t.distance=0,t.isVisited=!0,t.previousNode=null;for(var r=[];!a.isEmpty();){var i=a.front();if(a.dequeue(),e[i.row][i.col].isFinish)return r;for(var o=[[-1,0],[1,0],[0,1],[0,-1]],s=0;s<o.length;s++)i.row+o[s][0]>=0&&i.row+o[s][0]<20&&i.col+o[s][1]>=0&&i.col+o[s][1]<50&&!e[i.row+o[s][0]][i.col+o[s][1]].isVisited&&!e[i.row+o[s][0]][i.col+o[s][1]].isWall&&(a.enqueue(e[i.row+o[s][0]][i.col+o[s][1]]),e[i.row+o[s][0]][i.col+o[s][1]].isVisited=!0,e[i.row+o[s][0]][i.col+o[s][1]].distance=e[i.row][i.col].distance+1,e[i.row+o[s][0]][i.col+o[s][1]].previousNode=e[i.row][i.col],console.log(e[i.row+o[s][0]][i.col+o[s][1]]),r.push(e[i.row+o[s][0]][i.col+o[s][1]]))}}var b=function e(){Object(s.a)(this,e);var t=[],n=0,a=-1,r=0;this.enqueue=function(e){t[++a]=e,r++},this.dequeue=function(){var e=n++,a=t[e];return t[e]=null,r--,a},this.front=function(){return t[n]},this.rear=function(){return t[a]},this.isEmpty=function(){return 0===r},this.size=function(){return r},this.print=function(){var e=t.filter((function(e){return null!==e}));console.log(e.toString())}};function w(e,t,n){var a=[];return function e(t,n,a,r){var i=n;if(n.isVisitedNode=!0,r.push(i),a===n)return 1;if(i.col+1<50&&!t[i.row][i.col+1].isVisitedNode&&!t[i.row][i.col+1].isWall&&(t[i.row][i.col+1].previousNode=t[i.row][i.col],e(t,t[i.row][i.col+1],a,r)))return 1;if(i.row-1>=0&&!t[i.row-1][i.col].isVisitedNode&&!t[i.row-1][i.col].isWall&&(t[i.row-1][i.col].previousNode=t[i.row][i.col],e(t,t[i.row-1][i.col],a,r)))return 1;if(i.row+1<20&&!t[i.row+1][i.col].isVisitedNode&&!t[i.row+1][i.col].isWall&&(t[i.row+1][i.col].previousNode=t[i.row][i.col],e(t,t[i.row+1][i.col],a,r)))return 1;if(i.col-1>=0&&!t[i.row][i.col-1].isVisitedNode&&!t[i.row][i.col-1].isWall&&(t[i.row][i.col-1].previousNode=t[i.row][i.col],e(t,t[i.row][i.col-1],a,r)))return 1}(e,t,n,a),a}function y(e,t,n){var a=[],r=[],i=[];for(r.push(t),t.distance=0;r.length;){r.sort((function(e,t){return e.distance+e.hdistance-(t.distance+t.hdistance)}));var o=r.shift();if(i.push(o),o.isVisitedNode=!0,a.push(o),o===n)return a;for(var s=E(o,e),l=0;l<s.length;l++){var c=s[l];if(!c.isWall&&!i.includes(c)){var u=o.distance+N(o,c);console.log(u),console.log(c.distance),(u<c.distance||!r.includes(c))&&(c.distance=u,c.hdistance=N(c,n),c.previousNode=o,r.includes(c)||(r.push(c),console.log(c)))}}}}function E(e,t){var n=[],a=e.col,r=e.row;return r>0&&n.push(t[r-1][a]),r<t.length-1&&n.push(t[r+1][a]),a>0&&n.push(t[r][a-1]),a<t[0].length-1&&n.push(t[r][a+1]),n}function N(e,t){return Math.abs(e.row-t.row)+Math.abs(e.col-t.col)}function x(e,t,n){var a=[];a.push(t),t.distance=0,t.isVisited=!0,t.previousNode=null;for(var r=[];a.length;){var i=a.shift();if(e[i.row][i.col].isFinish)return r;for(var o=[[-1,0],[1,0],[0,1],[0,-1]],s=0;s<o.length;s++)i.row+o[s][0]>=0&&i.row+o[s][0]<20&&i.col+o[s][1]>=0&&i.col+o[s][1]<50&&!e[i.row+o[s][0]][i.col+o[s][1]].isVisited&&!e[i.row+o[s][0]][i.col+o[s][1]].isWall&&(a.push(e[i.row+o[s][0]][i.col+o[s][1]]),e[i.row+o[s][0]][i.col+o[s][1]].isVisited=!0,e[i.row+o[s][0]][i.col+o[s][1]].distance=e[i.row][i.col].distance+1,e[i.row+o[s][0]][i.col+o[s][1]].previousNode=e[i.row][i.col],console.log(e[i.row+o[s][0]][i.col+o[s][1]]),r.push(e[i.row+o[s][0]][i.col+o[s][1]]));a.sort((function(e,t){return e.distance-t.distance}))}}var S=n(6),k=n(17),j=n.n(k),O=(a.Component,n(1)),C=(n(8),function(e){Object(c.a)(n,e);var t=Object(u.a)(n);function n(){var e;Object(s.a)(this,n);for(var a=arguments.length,r=new Array(a),i=0;i<a;i++)r[i]=arguments[i];return(e=t.call.apply(t,[this].concat(r))).state={path:"./"},e}return Object(l.a)(n,[{key:"componentDidMount",value:function(){this.props.running?this.setState({path:" "}):this.setState({path:" ./"}),console.log(this.state.path)}},{key:"render",value:function(){this.state.path;return r.a.createElement("nav",{className:"navbar  navbar-light default-color lighten-4"},r.a.createElement("span",{className:"navbar-brand mb-0 h1"},"Visulaizer"),r.a.createElement(O.b,{className:" Container home ",to:{pathname:"./"}},"Home"))}}]),n}(a.Component)),I=function(e){Object(c.a)(n,e);var t=Object(u.a)(n);function n(){return Object(s.a)(this,n),t.apply(this,arguments)}return Object(l.a)(n,[{key:"render",value:function(){return r.a.createElement("div",null,r.a.createElement("div",{className:"row"},r.a.createElement("div",{className:"col-xs-6"},r.a.createElement("div",{className:"node node-start ",style:{margin:"7px"}})),r.a.createElement("div",{className:"col-xs-6"},r.a.createElement("p",{style:{padding:"5px"}},"Represents Start Node"))),r.a.createElement("div",{className:"row"},r.a.createElement("div",{className:"col-xs-6"},r.a.createElement("div",{className:"node node-wall ",style:{margin:"7px"}})),r.a.createElement("div",{className:"col-xs-6"},r.a.createElement("p",{style:{padding:"5px"}},"Represents wall"))),r.a.createElement("div",{className:"row"},r.a.createElement("div",{className:"col-xs-6"},r.a.createElement("div",{className:"node node-finish ",style:{margin:"7px"}})),r.a.createElement("div",{className:"col-xs-6"},r.a.createElement("p",{style:{padding:"5px"}},"Represents Finish Node"))))}}]),n}(a.Component),A=(n(58),function(e){Object(c.a)(n,e);var t=Object(u.a)(n);function n(){var e;return Object(s.a)(this,n),(e=t.call(this)).state={grid:[],mouseIsPressed:!1,isRunning:!1,algo:[],heading:0,modalShow:!1},e}return Object(l.a)(n,[{key:"setmodalShow",value:function(e){this.setState({modalShow:!0})}},{key:"componentDidMount",value:function(){var e=B(20,50);this.setState({grid:e}),this.state.algo.push(m),this.state.algo.push(v),this.state.algo.push(w),this.state.algo.push(y),this.state.algo.push(x)}},{key:"handleMouseDown",value:function(e,t){if(!this.state.isRunning){var n=q(this.state.grid,e,t);this.setState({grid:n,mouseIsPressed:!0})}}},{key:"handleMouseEnter",value:function(e,t){if(!this.state.isRunning){if(!this.state.mouseIsPressed)return;var n=q(this.state.grid,e,t);this.setState({grid:n})}}},{key:"handleMouseUp",value:function(){this.state.isRunning||this.setState({mouseIsPressed:!1})}},{key:"animate",value:function(e,t){var n=this;if(!e)return this.setState({isRunning:!1}),void this.setState({heading:1});for(var a=function(a){if(a===e.length)return setTimeout((function(){n.animateShortestPath(t)}),5*a),{v:void 0};setTimeout((function(){var t=e[a],r=V(n.state.grid,t.row,t.col);n.setState({grid:r})}),5*a)},r=0;r<=e.length;r++){var i=a(r);if("object"===typeof i)return i.v}}},{key:"animateShortestPath",value:function(e){for(var t=this,n=function(n){setTimeout((function(){var a=e[n],r=M(t.state.grid,a.row,a.col);t.setState({grid:r})}),25*n)},a=0;a<e.length;a++)n(a);this.setState({isRunning:!1})}},{key:"visualize",value:function(){if(!this.state.isRunning){var e=this.props.location.state.algonum;console.log(e);var t=this.state.grid;this.setState({isRunning:!0});var n=t[10][15],a=t[10][35],r=this.state.algo[e](t,n,a),i=function(e){for(var t=[],n=e;null!==n;)console.log(n),console.log(n.isWall),console.log(n.previousNode),t.unshift(n),n=n.previousNode,console.log(n);return t}(a);this.animate(r,i)}}},{key:"reset",value:function(){if(!this.state.isRunning){var e=B(20,50);this.setState({grid:e}),this.setState({mouseIsPressed:!1}),this.setState({isRunning:!1})}}},{key:"render",value:function(){var e=this;0===this.state.heading||this.state.heading;var t=this.state.grid,n=this.state.mouseIsPressed;return this.props.location.state?r.a.createElement("div",null,r.a.createElement(C,null),r.a.createElement("div",{className:"rules"}," ",r.a.createElement(I,null)),r.a.createElement("div",{className:"h-100 row align-items-center"},r.a.createElement("div",{className:"grid "},t.map((function(t,a){return r.a.createElement("div",{key:a},t.map((function(t,a){var i=t.row,o=t.col,s=t.isFinish,l=t.isStart,c=t.isWall,u=t.isVisitednode,d=t.isShortestPath;return r.a.createElement(p,{key:a,col:o,isFinish:s,isStart:l,isWall:c,mouseIsPressed:n,isVisitednode:u,isShortestPath:d,onMouseDown:function(t,n){return e.handleMouseDown(t,n)},onMouseEnter:function(t,n){return e.handleMouseEnter(t,n)},onMouseUp:function(){return e.handleMouseUp()},row:i})})))})))),r.a.createElement("button",{style:{position:"fixed",top:"100px",right:"50px"},onClick:function(){return e.visualize()},className:"btn btn-primary"},"Visualize"),r.a.createElement("button",{className:"btn btn-primary",style:{position:"fixed",top:"200px",right:"50px"},onClick:function(){return e.reset()}},"Reset")):r.a.createElement(S.a,{to:"/Homepage"})}}]),n}(a.Component)),B=function(e,t){for(var n=[],a=0;a<e;a++){for(var r=[],i=0;i<t;i++)r.push(z(i,a));n.push(r)}return n},z=function(e,t){return{col:e,row:t,isStart:10===t&&15===e,isFinish:10===t&&35===e,distance:1/0,hdistance:1/0,isVisitednode:!1,isShortestPath:!1,isWall:!1,previousNode:null}},q=function(e,t,n){var a=e.slice(),r=a[t][n],i=Object(d.a)(Object(d.a)({},r),{},{isWall:!r.isWall});return a[t][n]=i,a},V=function(e,t,n){var a=e.slice(),r=a[t][n],i=Object(d.a)(Object(d.a)({},r),{},{isVisitednode:!0});return a[t][n]=i,a},M=function(e,t,n){var a=e.slice(),r=a[t][n],i=Object(d.a)(Object(d.a)({},r),{},{isShortestPath:!0});return a[t][n]=i,a},F=function(e){Object(c.a)(n,e);var t=Object(u.a)(n);function n(){var e;Object(s.a)(this,n);for(var a=arguments.length,r=new Array(a),i=0;i<a;i++)r[i]=arguments[i];return(e=t.call.apply(t,[this].concat(r))).state={},e}return Object(l.a)(n,[{key:"render",value:function(){return r.a.createElement("div",{className:"mainhome"},r.a.createElement(C,null),r.a.createElement("div",{className:"row"},r.a.createElement("div",{className:"col"},r.a.createElement("div",{className:"card pathcard shadow p-3 mb-5 bg-white rounded"},r.a.createElement("div",{className:"card-body"},r.a.createElement("h5",{className:"card-title"},this.props.title),r.a.createElement("p",{className:"card-text text-center font-weight-bold"},"Path finding algorithms"),r.a.createElement("ul",{class:"list-group list-group-flush"},r.a.createElement("li",{class:"list-group-item"}," ",r.a.createElement(O.b,{className:" link",to:{pathname:"/BFS"}},"BFS")),r.a.createElement("li",{class:"list-group-item"},r.a.createElement(O.b,{className:"link",to:{pathname:"/BestFS"}},"BestFS")),r.a.createElement("li",{class:"list-group-item"}," ",r.a.createElement(O.b,{className:" link",to:{pathname:"/Astar"}},"Astar")),r.a.createElement("li",{class:"list-group-item"},r.a.createElement(O.b,{className:" link",to:{pathname:"/Dijkstra"}},"Dijkstra")),r.a.createElement("li",{class:"list-group-item"},r.a.createElement(O.b,{className:" link",to:{pathname:"/DFS"}},"DFS")))))),r.a.createElement("div",{className:"col"},r.a.createElement("div",{className:"card  sortingcard shadow p-3 mb-5 bg-white rounded"},r.a.createElement("div",{className:"card-body"},r.a.createElement("h5",{className:"card-title"},this.props.title),r.a.createElement("p",{className:"card-text text-center font-weight-bold"},"Sorting algorithms"),r.a.createElement("ul",{class:"list-group list-group-flush"},r.a.createElement("li",{class:"list-group-item"},r.a.createElement(O.b,{className:" link",to:{pathname:"/MergeSort"}},"MergeSort")),r.a.createElement("li",{class:"list-group-item"},r.a.createElement(O.b,{className:" link",to:{pathname:"/BubbleSort"}},"BubbleSort")),r.a.createElement("li",{class:"list-group-item"},r.a.createElement(O.b,{className:" link",to:{pathname:"./QuickSort"}},"QuickSort")),r.a.createElement("li",{class:"list-group-item"}," ",r.a.createElement(O.b,{className:" link",to:{pathname:"./InsertionSort"}},"InsertionSort")),r.a.createElement("li",{class:"list-group-item"}," ",r.a.createElement(O.b,{className:" link",to:{pathname:"./Heapsort"}},"Heapsort"))))))))}}]),n}(a.Component),D=n(35);function P(e){var t=[];if(e.length<=1)return e;var n=e.slice();return function e(t,n,a,r,i){if(n===a)return;var o=Math.floor((n+a)/2);e(r,n,o,t,i),e(r,o+1,a,t,i),function(e,t,n,a,r,i){var o=t,s=t,l=n+1;for(;s<=n&&l<=a;)i.push([s,l]),i.push([s,l]),r[s]<=r[l]?(i.push([o,r[s]]),e[o++]=r[s++]):(i.push([o,r[l]]),e[o++]=r[l++]);for(;s<=n;)i.push([s,s]),i.push([s,s]),i.push([o,r[s]]),e[o++]=r[s++];for(;l<=a;)i.push([l,l]),i.push([l,l]),i.push([o,r[l]]),e[o++]=r[l++]}(t,n,o,a,r,i)}(e,0,e.length-1,n,t),t}n(59);function T(e){var t=[];return function e(t,n,a,r){if(n<a){var i=function(e,t,n,a){for(var r=e[n],i=t-1,o=t;o<=n-1;o++)if(a.push([o,n,1]),a.push([o,n,2]),e[o]<r){i++,a.push([i,o,0]);var s=e[o];e[o]=e[i],e[i]=s}a.push([i+1,n,0]);var l=e[n];return e[n]=e[i+1],e[i+1]=l,i+1}(t,n,a,r);e(t,n,i-1,r),e(t,i+1,a,r)}}(e,0,e.length-1,t),t}function W(e,t,n,a){var r=n,i=2*n+1,o=2*n+2;if(i<t&&e[i]>e[r]&&(r=i),o<t&&e[o]>e[r]&&(r=o),r!=n){a.push([n,r,1]),a.push([n,r,2]),a.push([n,r,0]);var s=e[n];e[n]=e[r],e[r]=s,W(e,t,r,a)}}var R=function(e){Object(c.a)(n,e);var t=Object(u.a)(n);function n(){var e;Object(s.a)(this,n);for(var a=arguments.length,r=new Array(a),i=0;i<a;i++)r[i]=arguments[i];return(e=t.call.apply(t,[this].concat(r))).state={path:"./"},e}return Object(l.a)(n,[{key:"componentDidMount",value:function(){this.props.running?this.setState({path:" "}):this.setState({path:" ./"}),console.log(this.state.path)}},{key:"render",value:function(){this.state.path;return r.a.createElement("nav",{className:"navbar  navbar-light default-color lighten-4"},r.a.createElement("span",{className:"navbar-brand mb-0 h1"},"Visulaizer"))}}]),n}(a.Component),L=function(e){Object(c.a)(n,e);var t=Object(u.a)(n);function n(e){var a;return Object(s.a)(this,n),(a=t.call(this,e)).state={array:[],running:!1},a}return Object(l.a)(n,[{key:"componentDidMount",value:function(){this.resetArray()}},{key:"resetArray",value:function(){if(!this.state.running){for(var e=[],t=0;t<300;t++)e.push((n=5,a=600,Math.floor(Math.random()*(a-n+1)+n)));this.setState({array:e})}var n,a}},{key:"sort",value:function(){if(!this.state.running){var e=this.props.location.state.algonum;console.log(e),0===e?this.mergeSort():1===e?this.quickSort():2===e?this.Inserion():3===e?this.bubbleSort():this.heapsort()}}},{key:"mergeSort",value:function(){console.log("doing merge sort");for(var e=P(this.state.array),t=function(t){var n=document.getElementsByClassName("array-bar");if(t%3!==2){var a=Object(D.a)(e[t],2),r=a[0],i=a[1],o=n[r].style,s=n[i].style,l=t%3===0?"red":"turquoise";setTimeout((function(){o.backgroundColor=l,s.backgroundColor=l}),2*t)}else setTimeout((function(){var a=e[t][0],r=e[t][1];n[a].style.height="".concat(r,"px")}),2*t)},n=0;n<e.length;n++)t(n)}},{key:"Inserion",value:function(){console.log("doing Isertio sort sort"),console.log(this.state.array);var e=function(e,t,n){var a,r,i=[];for(a=1;a<e.length;a++){r=e[a];for(var o=a-1;o>=0&&(i.push([o,a,1]),i.push([o,a,2]),e[o]>r);)i.push([o+1,e[o],0]),e[o+1]=e[o],o-=1;i.push([o+1,r,0]),e[o+1]=r}return i}(this.state.array);console.log(this.state.array),console.log(e);for(var t=function(t){var n=document.getElementsByClassName("array-bar");if(e[t][2]){var a,r=e[t][0],i=e[t][1],o=n[r].style,s=n[i].style;a=1===e[t][2]?"red":"turquoise",setTimeout((function(){o.backgroundColor=a,s.backgroundColor=a}),2*t)}else setTimeout((function(){var a=e[t][0],r=e[t][1];n[a].style.height="".concat(r,"px")}),2*t)},n=0;n<e.length;n++)t(n)}},{key:"quickSort",value:function(){console.log("doing Quick sort"),console.log(this.state.array);var e=T(this.state.array);console.log(this.state.array),console.log(e);for(var t=function(t){var n=document.getElementsByClassName("array-bar");if(!n)return{v:void 0};if(e[t][2]){var a,r=e[t][0],i=e[t][1],o=n[r].style,s=n[i].style;a=1===e[t][2]?"red":"turquoise",setTimeout((function(){o.backgroundColor=a,s.backgroundColor=a}),2*t)}else setTimeout((function(){var a=e[t][0],r=e[t][1],i=n[a].style,o=n[r].style,s=i.height,l=o.height;console.log(s),console.log(l),i.height="".concat(l),o.height="".concat(s)}),2*t)},n=0;n<e.length;n++){var a=t(n);if("object"===typeof a)return a.v}}},{key:"bubbleSort",value:function(){console.log("doing Bubble sort"),console.log(this.state.array);var e=function(e){var t,n,a=[];for(t=1;t<e.length;t++)for(n=0;n<e.length-t;n++)if(a.push([n,n+1,1]),a.push([n,n+1,2]),e[n]>e[n+1]){a.push([n,n+1,0]);var r=e[n];e[n]=e[n+1],e[n+1]=r}return a}(this.state.array);console.log(this.state.array),console.log(e);for(var t=function(t){var n=document.getElementsByClassName("array-bar");if(!n)return{v:void 0};if(e[t][2]){var a,r=e[t][0],i=e[t][1],o=n[r].style,s=n[i].style;a=1===e[t][2]?"red":"turquoise",setTimeout((function(){o.backgroundColor=a,s.backgroundColor=a}),2*t)}else setTimeout((function(){var a=e[t][0],r=e[t][1],i=n[a].style,o=n[r].style,s=i.height,l=o.height;console.log(s),console.log(l),i.height="".concat(l),o.height="".concat(s)}),2*t)},n=0;n<e.length;n++){var a=t(n);if("object"===typeof a)return a.v}}},{key:"heapsort",value:function(){console.log("doing heap sort"),console.log(this.state.array);var e=function(e){for(var t=[],n=e.length,a=n/2-1;a>=0;a--)W(e,n,a,t);for(var r=n-1;r>0;r--){t.push([0,r,1]),t.push([0,r,2]),t.push([0,r,0]);var i=e[r];e[r]=e[0],e[0]=i,W(e,r,0,t)}return t}(this.state.array);console.log(this.state.array),console.log(e);for(var t=function(t){var n=document.getElementsByClassName("array-bar");if(!n)return{v:void 0};if(e[t][2]){var a,r=e[t][0],i=e[t][1],o=n[r].style,s=n[i].style;a=1===e[t][2]?"red":"turquoise",setTimeout((function(){o.backgroundColor=a,s.backgroundColor=a}),2*t)}else setTimeout((function(){var a=e[t][0],r=e[t][1],i=n[a].style,o=n[r].style,s=i.height,l=o.height;i.height="".concat(l),o.height="".concat(s)}),2*t)},n=0;n<e.length;n++){var a=t(n);if("object"===typeof a)return a.v}}},{key:"render",value:function(){var e=this,t=this.state.array;if(!this.props.location.state)return r.a.createElement(S.a,{to:"/Homepage"});return r.a.createElement("div",{className:"visualizepage"},r.a.createElement(R,null),r.a.createElement("div",{className:"array-container visualizecontainer "},t.map((function(e,t){return r.a.createElement("div",{className:"array-bar",key:t,style:{backgroundColor:"turquoise",height:"".concat(e,"px")}})})),r.a.createElement("button",{style:{position:"fixed",top:"100px",right:"50px"},className:"btn btn-primary link1 ",onClick:function(){return e.resetArray()}},"Generate New Array"),r.a.createElement("button",{style:{position:"fixed",top:"200px",right:"50px"},className:"btn btn-primary link2 ",onClick:function(){return e.sort()}},"Sort")))}}]),n}(r.a.Component);var Q=n(254),U=n(253),_=function(e){Object(c.a)(n,e);var t=Object(u.a)(n);function n(){var e;Object(s.a)(this,n);for(var a=arguments.length,r=new Array(a),i=0;i<a;i++)r[i]=arguments[i];return(e=t.call.apply(t,[this].concat(r))).state={},e}return Object(l.a)(n,[{key:"render",value:function(){return r.a.createElement("div",null,r.a.createElement(C,null),r.a.createElement("div",{className:""},r.a.createElement("div",{className:"row"},r.a.createElement("div",{className:"col-5 float-left"},r.a.createElement("div",{className:"CodeBLock"},r.a.createElement("p",{className:"text-center font-weight-bold"},"Code"),r.a.createElement(Q.a,{language:"javascript",style:U.a},"\n    export function BFS(grid, startNode, finishNode) {\n        var q = new Queue();\n      \n        q.enqueue(startNode);\n      \n        startNode.distance = 0;\n        startNode.isVisited = true;\n        startNode.previousNode = null;\n      \n        const visitedNodesInOrder = [];\n      \n        while (!q.isEmpty()) {\n          var p = q.front();\n      \n          q.dequeue();\n      \n          // Destination found;\n          if (grid[p.row][p.col].isFinish) return visitedNodesInOrder;\n      \n          var x = [\n            [-1, 0],\n            [1, 0],\n            [0, 1],\n            [0, -1],\n          ];\n      \n          for (var i = 0; i < x.length; i++) {\n            if (\n              p.row + x[i][0] >= 0 &&\n              p.row + x[i][0] < 20 &&\n              p.col + x[i][1] >= 0 &&\n              p.col + x[i][1] < 50 &&\n              !grid[p.row + x[i][0]][p.col + x[i][1]].isVisited &&\n              !grid[p.row + x[i][0]][p.col + x[i][1]].isWall\n            ) {\n              q.enqueue(grid[p.row + x[i][0]][p.col + x[i][1]]);\n              grid[p.row + x[i][0]][p.col + x[i][1]].isVisited = true;\n              grid[p.row + x[i][0]][p.col + x[i][1]].distance =\n                grid[p.row][p.col].distance + 1;\n      \n              grid[p.row + x[i][0]][p.col + x[i][1]].previousNode =\n                grid[p.row][p.col];\n      \n              console.log(grid[p.row + x[i][0]][p.col + x[i][1]]);\n              visitedNodesInOrder.push(grid[p.row + x[i][0]][p.col + x[i][1]]);\n            }\n          }\n        }\n      }\n"))),r.a.createElement("div",{className:"col-5 "},r.a.createElement("div",{className:"Explanation"},r.a.createElement("p",{className:"text-center font-weight-bold"},"Explanation"),r.a.createElement("ol",null,r.a.createElement("li",null,"Store each cell as a node with their row, column values and distance from source cell and previou n"),r.a.createElement("li",null,"Start BFS with source cell."),r.a.createElement("li",null,"Mark the source node as visted and make distance equal to 0"),r.a.createElement("li",null,"Keep updating distance from source value in each move. and Store previous node"),r.a.createElement("li",null,"Return distance when destination is met, else return -1 (no path exists in between source and destination).")))))),r.a.createElement(O.b,{className:" btn btn-primary",style:{position:"fixed",top:"100px",right:"50px"},to:{pathname:"./PathfindingVisualizer",state:{algonum:1}}},"Visualize BFS"))}}]),n}(a.Component),H=function(e){Object(c.a)(n,e);var t=Object(u.a)(n);function n(){var e;Object(s.a)(this,n);for(var a=arguments.length,r=new Array(a),i=0;i<a;i++)r[i]=arguments[i];return(e=t.call.apply(t,[this].concat(r))).state={},e}return Object(l.a)(n,[{key:"render",value:function(){return r.a.createElement("div",null,r.a.createElement(C,null),r.a.createElement("div",{className:""},r.a.createElement("div",{className:"row"},r.a.createElement("div",{className:"col-5 float-left"},r.a.createElement("div",{className:"CodeBLock"},r.a.createElement("p",{className:"text-center font-weight-bold"},"Code"),r.a.createElement(Q.a,{language:"cpp",style:U.a},"\n    export function DFS(grid, startNode, finishNode) {\n        const visitedNodesInOrder = [];\n        DFSUtil(grid, startNode, finishNode, visitedNodesInOrder);\n        return visitedNodesInOrder;\n      }\n      \n      function DFSUtil(grid, node, finishNode, visitedNodesInOrder) {\n        var p = node;\n        node.isVisitedNode = true;\n        visitedNodesInOrder.push(p);\n      \n        if (finishNode === node) return 1;\n      \n        // moving right\n        if (\n          p.col + 1 < 50 &&\n          !grid[p.row][p.col + 1].isVisitedNode &&\n          !grid[p.row][p.col + 1].isWall\n        ) {\n          grid[p.row][p.col + 1].previousNode = grid[p.row][p.col];\n          if (DFSUtil(grid, grid[p.row][p.col + 1], finishNode, visitedNodesInOrder))\n            return 1;\n        }\n      \n        // moving up\n        if (\n          p.row - 1 >= 0 &&\n          !grid[p.row - 1][p.col].isVisitedNode &&\n          !grid[p.row - 1][p.col].isWall\n        ) {\n          grid[p.row - 1][p.col].previousNode = grid[p.row][p.col];\n          if (DFSUtil(grid, grid[p.row - 1][p.col], finishNode, visitedNodesInOrder))\n            return 1;\n        }\n      \n        // moving down\n        if (\n          p.row + 1 < 20 &&\n          !grid[p.row + 1][p.col].isVisitedNode &&\n          !grid[p.row + 1][p.col].isWall\n        ) {\n          grid[p.row + 1][p.col].previousNode = grid[p.row][p.col];\n          if (DFSUtil(grid, grid[p.row + 1][p.col], finishNode, visitedNodesInOrder))\n            return 1;\n        }\n      \n        // moving left\n        if (\n          p.col - 1 >= 0 &&\n          !grid[p.row][p.col - 1].isVisitedNode &&\n          !grid[p.row][p.col - 1].isWall\n        ) {\n          grid[p.row][p.col - 1].previousNode = grid[p.row][p.col];\n          if (DFSUtil(grid, grid[p.row][p.col - 1], finishNode, visitedNodesInOrder))\n            return 1;\n        }\n      }\n      \n"))),r.a.createElement("div",{className:"col-5 "},r.a.createElement("div",{className:"Explanation"},r.a.createElement("p",{className:"text-center font-weight-bold"},"Explanation"),r.a.createElement("ol",null,r.a.createElement("li",null,"Store each cell as a node with their row, column values and distance from source cell."),r.a.createElement("li",null,"Start BFS with source cell."),r.a.createElement("li",null,"Make a visited array with all having \u201cfalse\u201d values except \u20180\u2019cells which are assigned \u201ctrue\u201d values as they can not be traversed."),r.a.createElement("li",null,"Keep updating distance from source value in each move."),r.a.createElement("li",null,"Return distance when destination is met, else return -1 (no path exists in between source and destination).")))))),r.a.createElement(O.b,{className:" btn btn-primary",style:{position:"fixed",top:"100px",right:"50px"},to:{pathname:"./PathfindingVisualizer",state:{algonum:2}}},"Visualize DFS"))}}]),n}(a.Component),K=function(e){Object(c.a)(n,e);var t=Object(u.a)(n);function n(){var e;Object(s.a)(this,n);for(var a=arguments.length,r=new Array(a),i=0;i<a;i++)r[i]=arguments[i];return(e=t.call.apply(t,[this].concat(r))).state={},e}return Object(l.a)(n,[{key:"render",value:function(){return r.a.createElement("div",null,r.a.createElement(C,null),r.a.createElement("div",{className:""},r.a.createElement("div",{className:"row"},r.a.createElement("div",{className:"col-5 float-left"},r.a.createElement("div",{className:"CodeBLock"},r.a.createElement("p",{className:"text-center font-weight-bold"},"Code"),r.a.createElement(Q.a,{language:"cpp",style:U.a},"\n    export function Astar(grid, startNode, finishNode) {\n        const visitedNodesInOrder = [];\n      \n        const openSet = [];\n        const closedSet = [];\n        openSet.push(startNode);\n      \n        startNode.distance = 0;\n        while (openSet.length) {\n          sortNodesByDistance(openSet); //sort with distance\n          const currentNode = openSet.shift();\n          closedSet.push(currentNode);\n          currentNode.isVisitedNode = true;\n      \n          visitedNodesInOrder.push(currentNode);\n      \n          // finally find the goal, trace path with parent\n          if (currentNode === finishNode) {\n            return visitedNodesInOrder;\n          }\n      \n          const Neighbours = getNeighbors(currentNode, grid);\n      \n          for (var i = 0; i < Neighbours.length; i++) {\n            let neighbour = Neighbours[i];\n      \n            if (neighbour.isWall || closedSet.includes(neighbour)) {\n              continue;\n            }\n      \n            let cost =\n              currentNode.distance + heuristic_cost_estimate(currentNode, neighbour);\n            console.log(cost);\n            console.log(neighbour.distance);\n      \n            if (cost < neighbour.distance || !openSet.includes(neighbour)) {\n              neighbour.distance = cost;\n              neighbour.hdistance = heuristic_cost_estimate(neighbour, finishNode);\n              neighbour.previousNode = currentNode;\n      \n              if (!openSet.includes(neighbour)) {\n                openSet.push(neighbour);\n                console.log(neighbour);\n              }\n            }\n          }\n        }\n      }\n      \n      function sortNodesByDistance(unvisitedNodes) {\n        unvisitedNodes.sort(\n          (nodeA, nodeB) =>\n            nodeA.distance + nodeA.hdistance - (nodeB.distance + nodeB.hdistance)\n        );\n      }\n      \n      function getNeighbors(node, grid) {\n        const neighbors = [];\n        const {col, row} = node;\n        if (row > 0) neighbors.push(grid[row - 1][col]);\n        if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n        if (col > 0) neighbors.push(grid[row][col - 1]);\n        if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n        return neighbors;\n      }\n      \n      function heuristic_cost_estimate(nodeA, nodeB) {\n        const deltaX = Math.abs(nodeA.row - nodeB.row);\n        const deltaY = Math.abs(nodeA.col - nodeB.col);\n      \n        return deltaX + deltaY;\n      }\n      \n      // Backtracks from the finishNode to find the shortest path.\n      // Only works when called *after* the dijkstra method above.\n      export function getNodesInShortestPathOrder(finishNode) {\n        const nodesInShortestPathOrder = [];\n        let currentNode = finishNode;\n        while (currentNode !== null) {\n          console.log(currentNode);\n          console.log(currentNode.isWall);\n          console.log(currentNode.previousNode);\n      \n          nodesInShortestPathOrder.unshift(currentNode);\n          currentNode = currentNode.previousNode;\n          console.log(currentNode);\n        }\n        return nodesInShortestPathOrder;\n      }\n      \n"))),r.a.createElement("div",{className:"col-5 "},r.a.createElement("div",{className:"Explanation"},r.a.createElement("p",{className:"text-center font-weight-bold"},"Explanation"),r.a.createElement("div",null,r.a.createElement("h6",null,"What is A* Search Algorithm? "),r.a.createElement("div",null,"A* Search algorithm is one of the best and popular technique used in path-finding and graph traversals."," "),r.a.createElement("h6",null,"Why A* Search Algorithm ?"),r.a.createElement("div",null,"Informally speaking, A* Search algorithms, unlike other traversal techniques, it has \u201cbrains\u201d. What it means is that it is really a smart algorithm which separates it from the other conventional algorithms. This fact is cleared in detail in below sections. And it is also worth mentioning that many games and web-based maps use this algorithm to find the shortest path very efficiently (approximation).")),"2a9d8f",r.a.createElement("ol",null,r.a.createElement("li",null,"Store each cell as a node with their row, column values and distance from source cell."),r.a.createElement("li",null,"Start BFS with source cell."),r.a.createElement("li",null,"Make a visited array with all having \u201cfalse\u201d values except \u20180\u2019cells which are assigned \u201ctrue\u201d values as they can not be traversed."),r.a.createElement("li",null,"Keep updating distance from source value in each move."),r.a.createElement("li",null,"Return distance when destination is met, else return -1 (no path exists in between source and destination).")))))),r.a.createElement(O.b,{className:" btn btn-primary",style:{position:"fixed",top:"100px",right:"50px"},to:{pathname:"./PathfindingVisualizer",state:{algonum:3}}},"Visualize Astar"))}}]),n}(a.Component),G=function(e){Object(c.a)(n,e);var t=Object(u.a)(n);function n(){var e;Object(s.a)(this,n);for(var a=arguments.length,r=new Array(a),i=0;i<a;i++)r[i]=arguments[i];return(e=t.call.apply(t,[this].concat(r))).state={},e}return Object(l.a)(n,[{key:"render",value:function(){return r.a.createElement("div",null,r.a.createElement(C,null),r.a.createElement("div",{className:""},r.a.createElement("div",{className:"row"},r.a.createElement("div",{className:"col-5 float-left"},r.a.createElement("div",{className:"CodeBLock"},r.a.createElement("p",{className:"text-center font-weight-bold"},"Code"),r.a.createElement(Q.a,{language:"javascript",style:U.a},"\n    export function BestFS(grid, startNode, finishNode) {\n        var q = [];\n      \n        q.push(startNode);\n      \n        startNode.distance = 0;\n        startNode.isVisited = true;\n        startNode.previousNode = null;\n      \n        const visitedNodesInOrder = [];\n      \n        while (q.length) {\n          var p = q.shift();\n      \n          // Destination found;\n          if (grid[p.row][p.col].isFinish) return visitedNodesInOrder;\n      \n          var x = [\n            [-1, 0],\n            [1, 0],\n            [0, 1],\n            [0, -1],\n          ];\n      \n          for (var i = 0; i < x.length; i++) {\n            if (\n              p.row + x[i][0] >= 0 &&\n              p.row + x[i][0] < 20 &&\n              p.col + x[i][1] >= 0 &&\n              p.col + x[i][1] < 50 &&\n              !grid[p.row + x[i][0]][p.col + x[i][1]].isVisited &&\n              !grid[p.row + x[i][0]][p.col + x[i][1]].isWall\n            ) {\n              q.push(grid[p.row + x[i][0]][p.col + x[i][1]]);\n      \n              grid[p.row + x[i][0]][p.col + x[i][1]].isVisited = true;\n              grid[p.row + x[i][0]][p.col + x[i][1]].distance =\n                grid[p.row][p.col].distance + 1;\n      \n              grid[p.row + x[i][0]][p.col + x[i][1]].previousNode =\n                grid[p.row][p.col];\n      \n              console.log(grid[p.row + x[i][0]][p.col + x[i][1]]);\n              visitedNodesInOrder.push(grid[p.row + x[i][0]][p.col + x[i][1]]);\n            }\n          }\n          sortNodesByDistance(q);\n        }\n      }\n      \n      export function getNodesInShortestPathOrderBFS(finishNode) {\n        const nodesInShortestPathOrder = [];\n        let currentNode = finishNode;\n        while (currentNode !== null) {\n          console.log(currentNode);\n          nodesInShortestPathOrder.unshift(currentNode);\n          var prenode = currentNode.previousNode;\n      \n          currentNode = currentNode.previousNode;\n          console.log(currentNode);\n          console.log(prenode);\n        }\n        return nodesInShortestPathOrder;\n      }\n      function sortNodesByDistance(unvisitedNodes) {\n        unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n      }\n      \n"))),r.a.createElement("div",{className:"col-5 "},r.a.createElement("div",{className:"Explanation"},r.a.createElement("p",{className:"text-center font-weight-bold"},"Explanation"),r.a.createElement("div",null,"Best-First-Search(Grah g, Node start)",r.a.createElement("p",null,"Create an empty PriorityQueue PriorityQueue pq;"),r.a.createElement("p",null," Until PriorityQueue is empty"),r.a.createElement("p",null," u = PriorityQueue.DeleteMin"),r.a.createElement("p",null)))))),r.a.createElement(O.b,{className:" btn btn-primary",style:{position:"fixed",top:"100px",right:"50px"},to:{pathname:"./PathfindingVisualizer",state:{algonum:4}}},"Visualize BestFS"))}}]),n}(a.Component),Y=function(e){Object(c.a)(n,e);var t=Object(u.a)(n);function n(){var e;Object(s.a)(this,n);for(var a=arguments.length,r=new Array(a),i=0;i<a;i++)r[i]=arguments[i];return(e=t.call.apply(t,[this].concat(r))).state={},e}return Object(l.a)(n,[{key:"render",value:function(){return r.a.createElement("div",null,r.a.createElement(C,null),r.a.createElement("div",{className:""},r.a.createElement("div",{className:"row"},r.a.createElement("div",{className:"col-5 float-left"},r.a.createElement("div",{className:"CodeBLock"},r.a.createElement("p",{className:"text-center font-weight-bold"},"Code"),r.a.createElement(Q.a,{language:"cpp",style:U.a},"\n    int ShortestPath(char grid[N][M]) \n{ \n    QItem source(0, 0, 0); \n  \n    // To keep track of visited QItems. Marking \n    // blocked cells as visited. \n    bool visited[N][M]; \n    for (int i = 0; i < N; i++) { \n        for (int j = 0; j < M; j++) \n        { \n            if (grid[i][j] == '0') \n                visited[i][j] = true; \n            else\n                visited[i][j] = false; \n  \n            // Finding source \n            if (grid[i][j] == 's') \n            { \n               source.row = i; \n               source.col = j; \n            } \n        } \n    } \n  \n    // applying BFS on matrix cells starting from source \n    queue<QItem> q; \n    q.push(source); \n    visited[source.row][source.col] = true; \n    while (!q.empty()) { \n        QItem p = q.front(); \n        q.pop(); \n  \n        // Destination found; \n        if (grid[p.row][p.col] == 'd') \n            return p.dist; \n  \n        // moving up \n        if (p.row - 1 >= 0 && \n            visited[p.row - 1][p.col] == false) { \n            q.push(QItem(p.row - 1, p.col, p.dist + 1)); \n            visited[p.row - 1][p.col] = true; \n        } \n  \n        // moving down \n        if (p.row + 1 < N && \n            visited[p.row + 1][p.col] == false) { \n            q.push(QItem(p.row + 1, p.col, p.dist + 1)); \n            visited[p.row + 1][p.col] = true; \n        } \n  \n        // moving left \n        if (p.col - 1 >= 0 && \n            visited[p.row][p.col - 1] == false) { \n            q.push(QItem(p.row, p.col - 1, p.dist + 1)); \n            visited[p.row][p.col - 1] = true; \n        } \n  \n         // moving right \n        if (p.col + 1 < M && \n            visited[p.row][p.col + 1] == false) { \n            q.push(QItem(p.row, p.col + 1, p.dist + 1)); \n            visited[p.row][p.col + 1] = true; \n        } \n    } \n    return -1; \n} \n"))),r.a.createElement("div",{className:"col-5 "},r.a.createElement("div",{className:"Explanation"},r.a.createElement("p",{className:"text-center font-weight-bold"},"Explanation"),r.a.createElement("ol",null,r.a.createElement("li",null,"Store each cell as a node with their row, column values and distance from source cell."),r.a.createElement("li",null,"Start BFS with source cell."),r.a.createElement("li",null,"Make a visited array with all having \u201cfalse\u201d values except \u20180\u2019cells which are assigned \u201ctrue\u201d values as they can not be traversed."),r.a.createElement("li",null,"Keep updating distance from source value in each move."),r.a.createElement("li",null,"Return distance when destination is met, else return -1 (no path exists in between source and destination).")))))),r.a.createElement(O.b,{className:" btn btn-primary",style:{position:"fixed",top:"100px",right:"50px"},to:{pathname:"./PathfindingVisualizer",state:{algonum:0}}},"Visualize Dijktra"))}}]),n}(a.Component),J=function(e){Object(c.a)(n,e);var t=Object(u.a)(n);function n(){var e;Object(s.a)(this,n);for(var a=arguments.length,r=new Array(a),i=0;i<a;i++)r[i]=arguments[i];return(e=t.call.apply(t,[this].concat(r))).state={},e}return Object(l.a)(n,[{key:"render",value:function(){return r.a.createElement("div",null,r.a.createElement(C,null),r.a.createElement("div",{className:""},r.a.createElement("div",{className:"row"},r.a.createElement("div",{className:"col-5 float-left"},r.a.createElement("div",{className:"CodeBLock"},r.a.createElement("p",{className:"text-center font-weight-bold"},"Code"),r.a.createElement(Q.a,{language:"cpp",style:U.a},'\n    // C++ program for implementation of Bubble sort \n    #include <bits/stdc++.h> \n    using namespace std; \n    \n    void swap(int *xp, int *yp) \n    { \n        int temp = *xp; \n        *xp = *yp; \n        *yp = temp; \n    } \n    \n    // A function to implement bubble sort \n    void bubbleSort(int arr[], int n) \n    { \n        int i, j; \n        for (i = 0; i < n-1; i++)\t \n        \n        // Last i elements are already in place \n        for (j = 0; j < n-i-1; j++) \n            if (arr[j] > arr[j+1]) \n                swap(&arr[j], &arr[j+1]); \n    } \n    \n    /* Function to print an array */\n    void printArray(int arr[], int size) \n    { \n        int i; \n        for (i = 0; i < size; i++) \n            cout << arr[i] << " "; \n        cout << endl; \n    } \n    \n    // Driver code \n    int main() \n    { \n        int arr[] = {64, 34, 25, 12, 22, 11, 90}; \n        int n = sizeof(arr)/sizeof(arr[0]); \n        bubbleSort(arr, n); \n        cout<<"Sorted array: \n"; \n        printArray(arr, n); \n        return 0; \n    } \n    \n'))),r.a.createElement("div",{className:"col-5 "},r.a.createElement("div",{className:"Explanation"},r.a.createElement("p",{className:"text-center font-weight-bold"},"Explanation"),r.a.createElement("p",null,"Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order."))))),r.a.createElement(O.b,{className:" btn btn-primary",style:{position:"fixed",top:"100px",right:"50px"},to:{pathname:"./Sorting",state:{algonum:3}}},"Visualize Bubble Sort"))}}]),n}(a.Component),X=function(e){Object(c.a)(n,e);var t=Object(u.a)(n);function n(){var e;Object(s.a)(this,n);for(var a=arguments.length,r=new Array(a),i=0;i<a;i++)r[i]=arguments[i];return(e=t.call.apply(t,[this].concat(r))).state={},e}return Object(l.a)(n,[{key:"render",value:function(){return r.a.createElement("div",null,r.a.createElement(C,null),r.a.createElement("div",{className:""},r.a.createElement("div",{className:"row"},r.a.createElement("div",{className:"col-5 float-left"},r.a.createElement("div",{className:"CodeBLock"},r.a.createElement("p",{className:"text-center font-weight-bold"},"Code"),r.a.createElement(Q.a,{language:"cpp",style:U.a},'\n    /* C++ implementation of QuickSort */\n    #include <bits/stdc++.h> \n    using namespace std; \n    \n    // A utility function to swap two elements \n    void swap(int* a, int* b) \n    { \n        int t = *a; \n        *a = *b; \n        *b = t; \n    } \n    \n    /* This function takes last element as pivot, places \n    the pivot element at its correct position in sorted \n    array, and places all smaller (smaller than pivot) \n    to left of pivot and all greater elements to right \n    of pivot */\n    int partition (int arr[], int low, int high) \n    { \n        int pivot = arr[high]; // pivot \n        int i = (low - 1); // Index of smaller element \n    \n        for (int j = low; j <= high - 1; j++) \n        { \n            // If current element is smaller than the pivot \n            if (arr[j] < pivot) \n            { \n                i++; // increment index of smaller element \n                swap(&arr[i], &arr[j]); \n            } \n        } \n        swap(&arr[i + 1], &arr[high]); \n        return (i + 1); \n    } \n    \n    /* The main function that implements QuickSort \n    arr[] --\x3e Array to be sorted, \n    low --\x3e Starting index, \n    high --\x3e Ending index */\n    void quickSort(int arr[], int low, int high) \n    { \n        if (low < high) \n        { \n            /* pi is partitioning index, arr[p] is now \n            at right place */\n            int pi = partition(arr, low, high); \n    \n            // Separately sort elements before \n            // partition and after partition \n            quickSort(arr, low, pi - 1); \n            quickSort(arr, pi + 1, high); \n        } \n    } \n    \n    /* Function to print an array */\n    void printArray(int arr[], int size) \n    { \n        int i; \n        for (i = 0; i < size; i++) \n            cout << arr[i] << " "; \n        cout << endl; \n    } \n    \n    // Driver Code \n    int main() \n    { \n        int arr[] = {10, 7, 8, 9, 1, 5}; \n        int n = sizeof(arr) / sizeof(arr[0]); \n        quickSort(arr, 0, n - 1); \n        cout << "Sorted array: \n"; \n        printArray(arr, n); \n        return 0; \n    } \n    \n    // This code is contributed by rathbhupendra \n    \n'))),r.a.createElement("div",{className:"col-5 "},r.a.createElement("div",{className:"Explanation"},r.a.createElement("p",{className:"text-center font-weight-bold"},"Explanation"),r.a.createElement("p",null,"Like Merge Sort, QuickSort is a Divide and Conquer algorithm. It picks an element as pivot and partitions the given array around the picked pivot. There are many different versions of quickSort that pick pivot in different ways.We use last element as pivot"),r.a.createElement("p",null,"The key process in quickSort is partition(). Target of partitions is, given an array and an element x of array as pivot, put x at its correct position in sorted array and put all smaller elements (smaller than x) before x, and put all greater elements (greater than x) after x. All this should be done in linear time."),r.a.createElement("h6",null,"Partition Algorithm "),r.a.createElement("p",null,"There can be many ways to do partition, following pseudo code adopts the method given in CLRS book. The logic is simple, we start from the leftmost element and keep track of index of smaller (or equal to) elements as i. While traversing, if we find a smaller element, we swap current element with arr[i]. Otherwise we ignore current element."))))),r.a.createElement(O.b,{className:" btn btn-primary",style:{position:"fixed",top:"100px",right:"50px"},to:{pathname:"./Sorting",state:{algonum:1}}},"Visualize Quick Sort"))}}]),n}(a.Component),$=function(e){Object(c.a)(n,e);var t=Object(u.a)(n);function n(){var e;Object(s.a)(this,n);for(var a=arguments.length,r=new Array(a),i=0;i<a;i++)r[i]=arguments[i];return(e=t.call.apply(t,[this].concat(r))).state={},e}return Object(l.a)(n,[{key:"render",value:function(){return r.a.createElement("div",null,r.a.createElement(C,null),r.a.createElement("div",{className:""},r.a.createElement("div",{className:"row"},r.a.createElement("div",{className:"col-5 float-left"},r.a.createElement("div",{className:"CodeBLock"},r.a.createElement("p",{className:"text-center font-weight-bold"},"Code"),r.a.createElement(Q.a,{language:"cpp",style:U.a},'\n    /* C program for Merge Sort */\n    #include <stdio.h> \n    #include <stdlib.h> \n    \n    // Merges two subarrays of arr[]. \n    // First subarray is arr[l..m] \n    // Second subarray is arr[m+1..r] \n    void merge(int arr[], int l, int m, int r) \n    { \n        int i, j, k; \n        int n1 = m - l + 1; \n        int n2 = r - m; \n    \n        /* create temp arrays */\n        int L[n1], R[n2]; \n    \n        /* Copy data to temp arrays L[] and R[] */\n        for (i = 0; i < n1; i++) \n            L[i] = arr[l + i]; \n        for (j = 0; j < n2; j++) \n            R[j] = arr[m + 1 + j]; \n    \n        /* Merge the temp arrays back into arr[l..r]*/\n        i = 0; // Initial index of first subarray \n        j = 0; // Initial index of second subarray \n        k = l; // Initial index of merged subarray \n        while (i < n1 && j < n2) { \n            if (L[i] <= R[j]) { \n                arr[k] = L[i]; \n                i++; \n            } \n            else { \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n    \n        /* Copy the remaining elements of L[], if there \n        are any */\n        while (i < n1) { \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n    \n        /* Copy the remaining elements of R[], if there \n        are any */\n        while (j < n2) { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n    \n    /* l is for left index and r is right index of the \n    sub-array of arr to be sorted */\n    void mergeSort(int arr[], int l, int r) \n    { \n        if (l < r) { \n            // Same as (l+r)/2, but avoids overflow for \n            // large l and h \n            int m = l + (r - l) / 2; \n    \n            // Sort first and second halves \n            mergeSort(arr, l, m); \n            mergeSort(arr, m + 1, r); \n    \n            merge(arr, l, m, r); \n        } \n    } \n    \n    /* UTILITY FUNCTIONS */\n    /* Function to print an array */\n    void printArray(int A[], int size) \n    { \n        int i; \n        for (i = 0; i < size; i++) \n            printf("%d ", A[i]); \n        printf("\n"); \n    } \n    \n    /* Driver program to test above functions */\n    int main() \n    { \n        int arr[] = { 12, 11, 13, 5, 6, 7 }; \n        int arr_size = sizeof(arr) / sizeof(arr[0]); \n    \n        printf("Given array is \n"); \n        printArray(arr, arr_size); \n    \n        mergeSort(arr, 0, arr_size - 1); \n    \n        printf("\nSorted array is \n"); \n        printArray(arr, arr_size); \n        return 0; \n    } \n    \n    \n'))),r.a.createElement("div",{className:"col-5 "},r.a.createElement("div",{className:"Explanation"},r.a.createElement("p",{className:"text-center font-weight-bold"},"Explanation"),r.a.createElement("p",null,"Like QuickSort, Merge Sort is a Divide and Conquer algorithm. It divides input array in two halves, calls itself for the two halves and then merges the two sorted halves. The merge() function is used for merging two halves. The merge(arr, l, m, r) is key process that assumes that arr[l..m] and arr[m+1..r] are sorted and merges the two sorted sub-arrays into one. See following C implementation for details."))))),r.a.createElement(O.b,{className:" btn btn-primary",style:{position:"fixed",top:"100px",right:"50px"},to:{pathname:"./Sorting",state:{algonum:0}}},"Visualize Merge Sort"))}}]),n}(a.Component),Z=function(e){Object(c.a)(n,e);var t=Object(u.a)(n);function n(){var e;Object(s.a)(this,n);for(var a=arguments.length,r=new Array(a),i=0;i<a;i++)r[i]=arguments[i];return(e=t.call.apply(t,[this].concat(r))).state={},e}return Object(l.a)(n,[{key:"render",value:function(){return r.a.createElement("div",null,r.a.createElement(C,null),r.a.createElement("div",{className:""},r.a.createElement("div",{className:"row"},r.a.createElement("div",{className:"col-5 float-left"},r.a.createElement("div",{className:"CodeBLock"},r.a.createElement("p",{className:"text-center font-weight-bold"},"Code"),r.a.createElement(Q.a,{language:"cpp",style:U.a},'\n    // C++ program for insertion sort \n    #include <bits/stdc++.h> \n    using namespace std; \n    \n    /* Function to sort an array using insertion sort*/\n    void insertionSort(int arr[], int n) \n    { \n        int i, key, j; \n        for (i = 1; i < n; i++) \n        { \n            key = arr[i]; \n            j = i - 1; \n    \n            /* Move elements of arr[0..i-1], that are \n            greater than key, to one position ahead \n            of their current position */\n            while (j >= 0 && arr[j] > key) \n            { \n                arr[j + 1] = arr[j]; \n                j = j - 1; \n            } \n            arr[j + 1] = key; \n        } \n    } \n    \n    // A utility function to print an array of size n \n    void printArray(int arr[], int n) \n    { \n        int i; \n        for (i = 0; i < n; i++) \n            cout << arr[i] << " "; \n        cout << endl; \n    } \n    \n    /* Driver code */\n    int main() \n    { \n        int arr[] = { 12, 11, 13, 5, 6 }; \n        int n = sizeof(arr) / sizeof(arr[0]); \n    \n        insertionSort(arr, n); \n        printArray(arr, n); \n    \n        return 0; \n    } \n    \n    // This is code is contributed by rathbhupendra \n    \n    \n'))),r.a.createElement("div",{className:"col-5 "},r.a.createElement("div",{className:"Explanation"},r.a.createElement("p",{className:"text-center font-weight-bold"},"Explanation"),r.a.createElement("p",null,"Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order."))))),r.a.createElement(O.b,{className:" btn btn-primary",style:{position:"fixed",top:"100px",right:"50px"},to:{pathname:"./Sorting",state:{algonum:2}}},"Visualize Insertion Sort"))}}]),n}(a.Component),ee=function(e){Object(c.a)(n,e);var t=Object(u.a)(n);function n(){var e;Object(s.a)(this,n);for(var a=arguments.length,r=new Array(a),i=0;i<a;i++)r[i]=arguments[i];return(e=t.call.apply(t,[this].concat(r))).state={},e}return Object(l.a)(n,[{key:"render",value:function(){return r.a.createElement("div",null,r.a.createElement(C,null),r.a.createElement("div",{className:""},r.a.createElement("div",{className:"row"},r.a.createElement("div",{className:"col-5 float-left"},r.a.createElement("div",{className:"CodeBLock"},r.a.createElement("p",{className:"text-center font-weight-bold"},"Code"),r.a.createElement(Q.a,{language:"cpp",style:U.a},'\n    // C++ program for implementation of Heap Sort \n#include <iostream> \n  \nusing namespace std; \n  \n// To heapify a subtree rooted with node i which is \n// an index in arr[]. n is size of heap \nvoid heapify(int arr[], int n, int i) \n{ \n    int largest = i; // Initialize largest as root \n    int l = 2*i + 1; // left = 2*i + 1 \n    int r = 2*i + 2; // right = 2*i + 2 \n  \n    // If left child is larger than root \n    if (l < n && arr[l] > arr[largest]) \n        largest = l; \n  \n    // If right child is larger than largest so far \n    if (r < n && arr[r] > arr[largest]) \n        largest = r; \n  \n    // If largest is not root \n    if (largest != i) \n    { \n        swap(arr[i], arr[largest]); \n  \n        // Recursively heapify the affected sub-tree \n        heapify(arr, n, largest); \n    } \n} \n  \n// main function to do heap sort \nvoid heapSort(int arr[], int n) \n{ \n    // Build heap (rearrange array) \n    for (int i = n / 2 - 1; i >= 0; i--) \n        heapify(arr, n, i); \n  \n    // One by one extract an element from heap \n    for (int i=n-1; i>0; i--) \n    { \n        // Move current root to end \n        swap(arr[0], arr[i]); \n  \n        // call max heapify on the reduced heap \n        heapify(arr, i, 0); \n    } \n} \n  \n/* A utility function to print array of size n */\nvoid printArray(int arr[], int n) \n{ \n    for (int i=0; i<n; ++i) \n        cout << arr[i] << " "; \n    cout << "\n"; \n} \n  \n// Driver program \nint main() \n{ \n    int arr[] = {12, 11, 13, 5, 6, 7}; \n    int n = sizeof(arr)/sizeof(arr[0]); \n  \n    heapSort(arr, n); \n  \n    cout << "Sorted array is \n"; \n    printArray(arr, n); \n}\n    \n'))),r.a.createElement("div",{className:"col-5 "},r.a.createElement("div",{className:"Explanation"},r.a.createElement("p",{className:"text-center font-weight-bold"},"Explanation"),r.a.createElement("ol",null,r.a.createElement("li",null,"Build a max heap from the input data."),r.a.createElement("li",null,"At this point, the largest item is stored at the root of the heap. Replace it with the last item of the heap followed by reducing the size of heap by 1. Finally, heapify the root of tree"),r.a.createElement("li",null,"Repeat above steps while size of heap is greater than 1.")))))),r.a.createElement(O.b,{className:" btn btn-primary",style:{position:"fixed",top:"100px",right:"50px"},to:{pathname:"./Sorting",state:{algonum:4}}},"Visualize Heap Sort"))}}]),n}(a.Component),te=function(e){Object(c.a)(n,e);var t=Object(u.a)(n);function n(){var e;Object(s.a)(this,n);for(var a=arguments.length,r=new Array(a),i=0;i<a;i++)r[i]=arguments[i];return(e=t.call.apply(t,[this].concat(r))).state={},e}return Object(l.a)(n,[{key:"render",value:function(){return r.a.createElement(O.a,{basename:"/"},r.a.createElement(S.b,{path:"/",exact:!0,component:F}),r.a.createElement(S.b,{path:"/PathfindingVisualizer",component:A}),r.a.createElement(S.b,{path:"/Homepage",component:F}),r.a.createElement(S.b,{path:"/Sorting",component:L}),r.a.createElement(S.b,{path:"/BFS",component:_}),r.a.createElement(S.b,{path:"/DFS",component:H}),r.a.createElement(S.b,{path:"/BestFS",component:G}),r.a.createElement(S.b,{path:"/Astar",component:K}),r.a.createElement(S.b,{path:"/Dijkstra",component:Y}),r.a.createElement(S.b,{path:"/MergeSort",component:$}),r.a.createElement(S.b,{path:"/QuickSort",component:X}),r.a.createElement(S.b,{path:"/BubbleSort",component:J}),r.a.createElement(S.b,{path:"/InsertionSort",component:Z}),r.a.createElement(S.b,{path:"/Heapsort",component:ee}))}}]),n}(a.Component);Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));n(251);o.a.render(r.a.createElement(te,null),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then((function(e){e.unregister()}))},36:function(e,t,n){e.exports=n(252)},41:function(e,t,n){},42:function(e,t,n){},43:function(e,t,n){},58:function(e,t,n){},59:function(e,t,n){},8:function(e,t,n){}},[[36,1,2]]]);
//# sourceMappingURL=main.aa45e0e4.chunk.js.map