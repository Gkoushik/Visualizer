{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","algorithms/BFS.js","algorithms/DFS.js","algorithms/Astar.js","algorithms/BestFS.js","Pages/Rule.jsx","Pages/Navbar.jsx","PathfindingVisualizer/PathfindingVisualizer.jsx","Pages/Code.jsx","Pages/Content.jsx","Pages/Homepage.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","isVisitednode","isShortestPath","extraClassName","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","BFS","q","Queue","enqueue","isEmpty","p","front","dequeue","x","i","console","log","items","rear","count","elm","current","temp","size","print","e","toString","DFS","DFSUtil","isVisitedNode","Astar","openSet","closedSet","hdistance","currentNode","Neighbours","getNeighbors","neighbour","includes","cost","heuristic_cost_estimate","Math","abs","BestFS","Rules","class","style","margin","padding","Navbar","state","to","pathname","PathfindingVisualizer","mouseIsPressed","isRunning","algo","getInitialGrid","setState","newGrid","getNewGridWithWallToggled","nodesInShortestPathOrder","setTimeout","animateShortestPath","getVisitedGrid","getShortestpathgrid","algonum","location","unshift","getNodesInShortestPathOrder","animate","initgridd","Rule","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","onClick","visualize","reset","y","currentRow","createNode","slice","newNode","Code","Content","title","refs","tag","Homepage","tags","App","basename","path","exact","component","Boolean","window","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.691f6c31.chunk.js","sourcesContent":["import React, {Component} from \"react\";\n\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      row,\n      isVisitednode,\n      isShortestPath,\n    } = this.props;\n\n    const extraClassName = isFinish\n      ? \"node-finish\"\n      : isStart\n      ? \"node-start\"\n      : isWall\n      ? \"node-wall\"\n      : isShortestPath\n      ? \"node-shortest-path\"\n      : isVisitednode\n      ? \"node-visited\"\n      : \"\";\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}  `}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}></div>\n    );\n  }\n}\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const {col, row} = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    console.log(currentNode);\n    console.log(currentNode.isWall);\n    console.log(currentNode.previousNode);\n\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n    console.log(currentNode);\n  }\n  return nodesInShortestPathOrder;\n}\n","export function BFS(grid, startNode, finishNode) {\r\n  var q = new Queue();\r\n\r\n  q.enqueue(startNode);\r\n\r\n  startNode.distance = 0;\r\n  startNode.isVisited = true;\r\n  startNode.previousNode = null;\r\n\r\n  const visitedNodesInOrder = [];\r\n\r\n  while (!q.isEmpty()) {\r\n    var p = q.front();\r\n\r\n    q.dequeue();\r\n\r\n    // Destination found;\r\n    if (grid[p.row][p.col].isFinish) return visitedNodesInOrder;\r\n\r\n    var x = [\r\n      [-1, 0],\r\n      [1, 0],\r\n      [0, 1],\r\n      [0, -1],\r\n    ];\r\n\r\n    for (var i = 0; i < x.length; i++) {\r\n      if (\r\n        p.row + x[i][0] >= 0 &&\r\n        p.row + x[i][0] < 20 &&\r\n        p.col + x[i][1] >= 0 &&\r\n        p.col + x[i][1] < 50 &&\r\n        !grid[p.row + x[i][0]][p.col + x[i][1]].isVisited &&\r\n        !grid[p.row + x[i][0]][p.col + x[i][1]].isWall\r\n      ) {\r\n        q.enqueue(grid[p.row + x[i][0]][p.col + x[i][1]]);\r\n        grid[p.row + x[i][0]][p.col + x[i][1]].isVisited = true;\r\n        grid[p.row + x[i][0]][p.col + x[i][1]].distance =\r\n          grid[p.row][p.col].distance + 1;\r\n\r\n        grid[p.row + x[i][0]][p.col + x[i][1]].previousNode =\r\n          grid[p.row][p.col];\r\n\r\n        console.log(grid[p.row + x[i][0]][p.col + x[i][1]]);\r\n        visitedNodesInOrder.push(grid[p.row + x[i][0]][p.col + x[i][1]]);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nclass Queue {\r\n  constructor() {\r\n    let items = [];\r\n    let front = 0;\r\n    let rear = -1;\r\n    let count = 0;\r\n\r\n    //Add a new element in queue\r\n    this.enqueue = (elm) => {\r\n      items[++rear] = elm;\r\n      count++;\r\n    };\r\n\r\n    //Remove element from the queue\r\n    this.dequeue = () => {\r\n      let current = front++;\r\n      let temp = items[current];\r\n      items[current] = null;\r\n      count--;\r\n      return temp;\r\n    };\r\n\r\n    //Return the first element from the queue\r\n    this.front = () => {\r\n      return items[front];\r\n    };\r\n\r\n    //Return the last element from the queue\r\n    this.rear = () => {\r\n      return items[rear];\r\n    };\r\n\r\n    //Check if queue is empty\r\n    this.isEmpty = () => {\r\n      return count === 0;\r\n    };\r\n\r\n    //Return the size of the queue\r\n    this.size = () => {\r\n      return count;\r\n    };\r\n\r\n    //Print the queue\r\n    this.print = () => {\r\n      let temp = items.filter((e) => e !== null);\r\n      console.log(temp.toString());\r\n    };\r\n  }\r\n}\r\n\r\nexport function getNodesInShortestPathOrderBFS(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    console.log(currentNode);\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    var prenode = currentNode.previousNode;\r\n\r\n    currentNode = currentNode.previousNode;\r\n    console.log(currentNode);\r\n    console.log(prenode);\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function DFS(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  DFSUtil(grid, startNode, finishNode, visitedNodesInOrder);\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction DFSUtil(grid, node, finishNode, visitedNodesInOrder) {\r\n  var p = node;\r\n  node.isVisitedNode = true;\r\n  visitedNodesInOrder.push(p);\r\n\r\n  if (finishNode === node) return 1;\r\n\r\n  // moving right\r\n  if (\r\n    p.col + 1 < 50 &&\r\n    !grid[p.row][p.col + 1].isVisitedNode &&\r\n    !grid[p.row][p.col + 1].isWall\r\n  ) {\r\n    grid[p.row][p.col + 1].previousNode = grid[p.row][p.col];\r\n    if (DFSUtil(grid, grid[p.row][p.col + 1], finishNode, visitedNodesInOrder))\r\n      return 1;\r\n  }\r\n\r\n  // moving up\r\n  if (\r\n    p.row - 1 >= 0 &&\r\n    !grid[p.row - 1][p.col].isVisitedNode &&\r\n    !grid[p.row - 1][p.col].isWall\r\n  ) {\r\n    grid[p.row - 1][p.col].previousNode = grid[p.row][p.col];\r\n    if (DFSUtil(grid, grid[p.row - 1][p.col], finishNode, visitedNodesInOrder))\r\n      return 1;\r\n  }\r\n\r\n  // moving down\r\n  if (\r\n    p.row + 1 < 20 &&\r\n    !grid[p.row + 1][p.col].isVisitedNode &&\r\n    !grid[p.row + 1][p.col].isWall\r\n  ) {\r\n    grid[p.row + 1][p.col].previousNode = grid[p.row][p.col];\r\n    if (DFSUtil(grid, grid[p.row + 1][p.col], finishNode, visitedNodesInOrder))\r\n      return 1;\r\n  }\r\n\r\n  // moving left\r\n  if (\r\n    p.col - 1 >= 0 &&\r\n    !grid[p.row][p.col - 1].isVisitedNode &&\r\n    !grid[p.row][p.col - 1].isWall\r\n  ) {\r\n    grid[p.row][p.col - 1].previousNode = grid[p.row][p.col];\r\n    if (DFSUtil(grid, grid[p.row][p.col - 1], finishNode, visitedNodesInOrder))\r\n      return 1;\r\n  }\r\n}\r\n","export function Astar(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n\r\n  const openSet = [];\r\n  const closedSet = [];\r\n  openSet.push(startNode);\r\n\r\n  startNode.distance = 0;\r\n  while (openSet.length) {\r\n    sortNodesByDistance(openSet); //sort with distance\r\n    const currentNode = openSet.shift();\r\n    closedSet.push(currentNode);\r\n    currentNode.isVisitedNode = true;\r\n\r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    // finally find the goal, trace path with parent\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    const Neighbours = getNeighbors(currentNode, grid);\r\n\r\n    for (var i = 0; i < Neighbours.length; i++) {\r\n      let neighbour = Neighbours[i];\r\n\r\n      if (neighbour.isWall || closedSet.includes(neighbour)) {\r\n        continue;\r\n      }\r\n\r\n      let cost =\r\n        currentNode.distance + heuristic_cost_estimate(currentNode, neighbour);\r\n      console.log(cost);\r\n      console.log(neighbour.distance);\r\n\r\n      if (cost < neighbour.distance || !openSet.includes(neighbour)) {\r\n        neighbour.distance = cost;\r\n        neighbour.hdistance = heuristic_cost_estimate(neighbour, finishNode);\r\n        neighbour.previousNode = currentNode;\r\n\r\n        if (!openSet.includes(neighbour)) {\r\n          openSet.push(neighbour);\r\n          console.log(neighbour);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort(\r\n    (nodeA, nodeB) =>\r\n      nodeA.distance + nodeA.hdistance - (nodeB.distance + nodeB.hdistance)\r\n  );\r\n}\r\n\r\nfunction getNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors;\r\n}\r\n\r\nfunction heuristic_cost_estimate(nodeA, nodeB) {\r\n  const deltaX = Math.abs(nodeA.row - nodeB.row);\r\n  const deltaY = Math.abs(nodeA.col - nodeB.col);\r\n\r\n  return deltaX + deltaY;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    console.log(currentNode);\r\n    console.log(currentNode.isWall);\r\n    console.log(currentNode.previousNode);\r\n\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n    console.log(currentNode);\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function BestFS(grid, startNode, finishNode) {\r\n  var q = [];\r\n\r\n  q.push(startNode);\r\n\r\n  startNode.distance = 0;\r\n  startNode.isVisited = true;\r\n  startNode.previousNode = null;\r\n\r\n  const visitedNodesInOrder = [];\r\n\r\n  while (q.length) {\r\n    var p = q.shift();\r\n\r\n    // Destination found;\r\n    if (grid[p.row][p.col].isFinish) return visitedNodesInOrder;\r\n\r\n    var x = [\r\n      [-1, 0],\r\n      [1, 0],\r\n      [0, 1],\r\n      [0, -1],\r\n    ];\r\n\r\n    for (var i = 0; i < x.length; i++) {\r\n      if (\r\n        p.row + x[i][0] >= 0 &&\r\n        p.row + x[i][0] < 20 &&\r\n        p.col + x[i][1] >= 0 &&\r\n        p.col + x[i][1] < 50 &&\r\n        !grid[p.row + x[i][0]][p.col + x[i][1]].isVisited &&\r\n        !grid[p.row + x[i][0]][p.col + x[i][1]].isWall\r\n      ) {\r\n        q.push(grid[p.row + x[i][0]][p.col + x[i][1]]);\r\n\r\n        grid[p.row + x[i][0]][p.col + x[i][1]].isVisited = true;\r\n        grid[p.row + x[i][0]][p.col + x[i][1]].distance =\r\n          grid[p.row][p.col].distance + 1;\r\n\r\n        grid[p.row + x[i][0]][p.col + x[i][1]].previousNode =\r\n          grid[p.row][p.col];\r\n\r\n        console.log(grid[p.row + x[i][0]][p.col + x[i][1]]);\r\n        visitedNodesInOrder.push(grid[p.row + x[i][0]][p.col + x[i][1]]);\r\n      }\r\n    }\r\n    sortNodesByDistance(q);\r\n  }\r\n}\r\n\r\nexport function getNodesInShortestPathOrderBFS(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    console.log(currentNode);\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    var prenode = currentNode.previousNode;\r\n\r\n    currentNode = currentNode.previousNode;\r\n    console.log(currentNode);\r\n    console.log(prenode);\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n","import React, {Component} from \"react\";\r\nimport \"../PathfindingVisualizer/Node/Node\";\r\n\r\nclass Rules extends Component {\r\n  render() {\r\n    return (\r\n      <div class=\"container\">\r\n        <div class=\"row\">\r\n          <div class=\"col-sm\">\r\n            <div class=\"row\">\r\n              <div class=\"col-xs-6\">\r\n                <div\r\n                  className={`node node-start `}\r\n                  style={{margin: \"7px\"}}></div>\r\n              </div>\r\n              <div class=\"col-xs-6\">\r\n                <p style={{padding: \"5px\"}}>Represents Start Node</p>\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div class=\"col-sm\">\r\n            <div class=\"row\">\r\n              <div class=\"col-xs-6\">\r\n                <div\r\n                  className={`node node-finish `}\r\n                  style={{margin: \"7px\"}}></div>\r\n              </div>\r\n              <div class=\"col-xs-6\">\r\n                <p style={{padding: \"5px\"}}>Represents Finish Node</p>\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div class=\"col-sm\">\r\n            <div class=\"row\">\r\n              <div class=\"col-xs-6\">\r\n                <div\r\n                  className={`node node-wall `}\r\n                  style={{margin: \"7px\"}}></div>\r\n              </div>\r\n              <div class=\"col-xs-6\">\r\n                <p style={{padding: \"5px\"}}>Represents wall</p>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Rules;\r\n","import React, {Component} from \"react\";\r\nimport {Link} from \"react-router-dom\";\r\nimport Rules from \"./Rule\";\r\n\r\nclass Navbar extends Component {\r\n  state = {};\r\n  render() {\r\n    return (\r\n      <nav class=\"navbar navbar-light bg-light\">\r\n        <span class=\"navbar-brand mb-0 h1\">Visulaizer</span>\r\n\r\n        <Link\r\n          className=\"container\"\r\n          to={{\r\n            pathname: \"/\",\r\n          }}>\r\n          Home\r\n        </Link>\r\n      </nav>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Navbar;\r\n","import React, {Component} from \"react\";\nimport Node from \"./Node/Node\";\nimport {dijkstra, getNodesInShortestPathOrder} from \"../algorithms/dijkstra\";\nimport {BFS} from \"../algorithms/BFS\";\nimport {DFS} from \"../algorithms/DFS\";\nimport {Astar} from \"../algorithms/Astar\";\nimport {BestFS} from \"../algorithms/BestFS\";\n\nimport Navbar from \"../Pages//Navbar\";\nimport Rules from \"../Pages/Rule\";\n\nimport \"./PathfindingVisualizer.css\";\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\nconst NO_ROWS = 20;\nconst NO_COLS = 50;\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      isRunning: false,\n      algo: [],\n    };\n  }\n\n  componentDidMount() {\n    const grid = getInitialGrid(NO_ROWS, NO_COLS);\n    this.setState({grid});\n    this.state.algo.push(dijkstra);\n    this.state.algo.push(BFS);\n    this.state.algo.push(DFS);\n    this.state.algo.push(Astar);\n    this.state.algo.push(BestFS);\n\n    // const {algo} = this.props.location.state;\n    // console.log(algo);\n  }\n\n  handleMouseDown(row, col) {\n    if (!this.state.isRunning) {\n      const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({grid: newGrid, mouseIsPressed: true});\n    }\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.isRunning) {\n      if (!this.state.mouseIsPressed) return;\n      const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({grid: newGrid});\n    }\n  }\n\n  handleMouseUp() {\n    if (!this.state.isRunning) {\n      this.setState({mouseIsPressed: false});\n    }\n  }\n\n  animate(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 5 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        const newGrid = getVisitedGrid(this.state.grid, node.row, node.col);\n        this.setState({grid: newGrid});\n      }, 5 * i);\n    }\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        const newGrid = getShortestpathgrid(\n          this.state.grid,\n          node.row,\n          node.col\n        );\n        this.setState({grid: newGrid});\n      }, 50 * i);\n    }\n  }\n\n  visualize() {\n    if (!this.state.isRunning) {\n      const {algonum} = this.props.location.state;\n      console.log(algonum);\n      const {grid} = this.state;\n      this.setState({isRunning: true});\n      const startNode = grid[START_NODE_ROW][START_NODE_COL];\n      const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n      const visitedNodesInOrder = this.state.algo[algonum](\n        grid,\n        startNode,\n        finishNode\n      );\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\n    }\n  }\n\n  reset() {\n    const initgridd = getInitialGrid(NO_ROWS, NO_COLS);\n    this.setState({grid: initgridd});\n    this.setState({mouseIsPressed: false});\n    this.setState({isRunning: false});\n  }\n\n  render() {\n    const grid = this.state.grid;\n    const mouseIsPressed = this.state.mouseIsPressed;\n\n    return (\n      <div>\n        <Navbar />\n        <Rules />\n        <div className=\"h-100 row align-items-center\">\n          <div className=\"grid \">\n            {grid.map((row, rowIdx) => {\n              return (\n                <div key={rowIdx}>\n                  {row.map((node, nodeIdx) => {\n                    const {\n                      row,\n                      col,\n                      isFinish,\n                      isStart,\n                      isWall,\n                      isVisitednode,\n                      isShortestPath,\n                    } = node;\n                    return (\n                      <Node\n                        key={nodeIdx}\n                        col={col}\n                        isFinish={isFinish}\n                        isStart={isStart}\n                        isWall={isWall}\n                        mouseIsPressed={mouseIsPressed}\n                        isVisitednode={isVisitednode}\n                        isShortestPath={isShortestPath}\n                        onMouseDown={(row, col) =>\n                          this.handleMouseDown(row, col)\n                        }\n                        onMouseEnter={(row, col) =>\n                          this.handleMouseEnter(row, col)\n                        }\n                        onMouseUp={() => this.handleMouseUp()}\n                        row={row}></Node>\n                    );\n                  })}\n                </div>\n              );\n            })}\n          </div>\n        </div>\n        <button onClick={() => this.visualize()} className=\"b\">\n          Visualize\n        </button>\n        <button onClick={() => this.reset()}>Reset</button>\n      </div>\n    );\n  }\n}\n\nconst getInitialGrid = (x, y) => {\n  const grid = [];\n\n  for (let row = 0; row < x; row++) {\n    const currentRow = [];\n    for (let col = 0; col < y; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    hdistance: Infinity,\n    isVisitednode: false,\n    isShortestPath: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getVisitedGrid = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isVisitednode: true,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getShortestpathgrid = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isShortestPath: true,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n","import React, {Component} from \"react\";\r\nimport {BFS} from \"../Codes/code.json\";\r\nimport {Link, Route} from \"react-router-dom\";\r\nimport Navbar from \"./Navbar\";\r\n\r\nclass Code extends Component {\r\n  state = {};\r\n  render() {\r\n    const {algo} = this.props.location.state;\r\n\r\n    return (\r\n      <div>\r\n        <Navbar />\r\n        <div class=\"container\">\r\n          <pre class=\"pre-scrollable\">\r\n            <code>\r\n              <h1>Title One</h1>\r\n              <p>A line of sample text</p>\r\n              <p>Another line of sample text</p>\r\n              <p>Yet another line of sample text</p>\r\n\r\n              <p>A line of sample text</p>\r\n              <p>Another line of sample text</p>\r\n              <p>Yet another line of sample text</p>\r\n\r\n              <p>A line of sample text</p>\r\n              <p>Another line of sample text</p>\r\n              <p>Yet another line of sample text</p>\r\n\r\n              <p>A line of sample text</p>\r\n              <p>Another line of sample text</p>\r\n              <p>Yet another line of sample text</p>\r\n            </code>\r\n          </pre>\r\n        </div>\r\n\r\n        <Link\r\n          className=\"container\"\r\n          to={{\r\n            pathname: \"/PathfindingVisualizer\",\r\n            state: {\r\n              algonum: algo[1],\r\n            },\r\n          }}>\r\n          {algo[0]}\r\n        </Link>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Code;\r\n","import React, {Component} from \"react\";\r\n// import {Link} from \"react-router\";\r\nimport {Link, Route} from \"react-router-dom\";\r\nimport Code from \"./Code\";\r\n\r\nimport \"./Content.css\";\r\n\r\nclass Content extends Component {\r\n  render() {\r\n    console.log(this.props);\r\n\r\n    return (\r\n      <div className=\"card\">\r\n        <div className=\"card-body\">\r\n          <h5 className=\"card-title\">{this.props.title}</h5>\r\n          <p className=\"card-text\">List of Sorting algorithms</p>\r\n\r\n          <ol className=\"container-fluid  \">\r\n            {this.props.refs.map((tag) => (\r\n              <Link\r\n                className=\"btn btn-primary link\"\r\n                to={{\r\n                  pathname: \"/Code\",\r\n                  state: {\r\n                    algo: tag,\r\n                  },\r\n                }}>\r\n                {tag[0]}\r\n              </Link>\r\n            ))}\r\n          </ol>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Content;\r\n","import React, {Component} from \"react\";\r\nimport Content from \"./Content\";\r\nimport Navbar from \"./Navbar\";\r\n\r\nclass Homepage extends Component {\r\n  state = {\r\n    tags: [\r\n      [\"BFS\", \"1\"],\r\n      [\"Dijkstra\", \"0\"],\r\n      [\"DFS (It doesn't garentee shortest path\", \"2\"],\r\n      [\"Astar\", \"3\"],\r\n      [\"BestFS\", \"4\"],\r\n    ],\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <Navbar />\r\n        {/* / <Content title={\"Sorting Path Finding\"} refs={this.state.tags} /> */}\r\n        <Content title={\"Path Finding\"} refs={this.state.tags} />\r\n        {/* <Content title={\"Graph\"} refs={this.state.tags} /> */}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Homepage;\r\n","import React from \"react\";\nimport \"./App.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\nimport Code from \"./Pages/Code\";\nimport Homepage from \"./Pages/Homepage\";\nimport {Route} from \"react-router-dom\";\nimport {HashRouter as Router} from \"react-router-dom\";\nfunction App() {\n  return (\n    <Router basename=\"/\">\n      <Route path=\"/\" exact component={Homepage} />\n      <Route path=\"/PathfindingVisualizer\" component={PathfindingVisualizer} />\n      <Route path=\"/Code\" component={Code} />\n      <Route path=\"/Homepage\" component={Homepage} />\n    </Router>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport \"bootstrap/dist/css/bootstrap.css\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}