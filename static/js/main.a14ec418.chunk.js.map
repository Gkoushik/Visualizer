{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","algorithms/BFS.js","algorithms/DFS.js","algorithms/Astar.js","algorithms/BestFS.js","Pages/Navbar.jsx","Pages/Rule.jsx","PathfindingVisualizer/PathfindingVisualizer.jsx","Pages/Homepage.jsx","sortingAlgorithms/sortingAlgorithms.js","sortingAlgorithms/Quicksort.js","SortingVisualizer/SortingVisualizer.jsx","sortingAlgorithms/InsertionSort.js","sortingAlgorithms/Bubblesort.js","PathFindingPages/BFS.jsx","PathFindingPages/DFS.jsx","PathFindingPages/Astar.jsx","PathFindingPages/BestFS.jsx","PathFindingPages/Dijkstra.jsx","SortAlgorithmPages/BubbleSort.jsx","SortAlgorithmPages/QuickSort.jsx","SortAlgorithmPages/MergeSort.jsx","SortAlgorithmPages/InsertionSort.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","isVisitednode","isShortestPath","extraClassName","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","BFS","q","Queue","enqueue","isEmpty","p","front","dequeue","x","i","console","log","items","rear","count","elm","current","temp","size","print","e","toString","DFS","DFSUtil","isVisitedNode","Astar","openSet","closedSet","hdistance","currentNode","Neighbours","getNeighbors","neighbour","includes","cost","heuristic_cost_estimate","Math","abs","BestFS","Navbar","state","path","running","setState","to","pathname","Rules","style","margin","padding","PathfindingVisualizer","mouseIsPressed","isRunning","algo","getInitialGrid","newGrid","getNewGridWithWallToggled","nodesInShortestPathOrder","setTimeout","animateShortestPath","getVisitedGrid","getShortestpathgrid","algonum","location","unshift","getNodesInShortestPathOrder","animate","initgridd","Rule","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","position","top","right","onClick","visualize","reset","y","currentRow","createNode","slice","newNode","Homepage","title","class","getMergeSortAnimations","array","animations","auxiliaryArray","mergeSortHelper","mainArray","startIdx","endIdx","middleIdx","floor","k","j","doMerge","quickSort","quickSorthelper","low","high","pi","pivot","partition","SortingVisualizer","resetArray","min","max","random","mergeSort","Inserion","bubbleSort","arrayBars","document","getElementsByClassName","barOneIdx","barTwoIdx","barOneStyle","barTwoStyle","color","backgroundColor","newHeight","height","arr","InsertionSort","l","r","BubbleSort","value","idx","React","language","docco","App","basename","exact","component","Dijkstra","MergeSort","QuickSort","Boolean","window","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.a14ec418.chunk.js","sourcesContent":["import React, {Component} from \"react\";\n\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      row,\n      isVisitednode,\n      isShortestPath,\n    } = this.props;\n\n    const extraClassName = isFinish\n      ? \"node-finish\"\n      : isStart\n      ? \"node-start\"\n      : isWall\n      ? \"node-wall\"\n      : isShortestPath\n      ? \"node-shortest-path\"\n      : isVisitednode\n      ? \"node-visited\"\n      : \"\";\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}  `}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}></div>\n    );\n  }\n}\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const {col, row} = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    console.log(currentNode);\n    console.log(currentNode.isWall);\n    console.log(currentNode.previousNode);\n\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n    console.log(currentNode);\n  }\n  return nodesInShortestPathOrder;\n}\n","export function BFS(grid, startNode, finishNode) {\r\n  var q = new Queue();\r\n\r\n  q.enqueue(startNode);\r\n\r\n  startNode.distance = 0;\r\n  startNode.isVisited = true;\r\n  startNode.previousNode = null;\r\n\r\n  const visitedNodesInOrder = [];\r\n\r\n  while (!q.isEmpty()) {\r\n    var p = q.front();\r\n\r\n    q.dequeue();\r\n\r\n    // Destination found;\r\n    if (grid[p.row][p.col].isFinish) return visitedNodesInOrder;\r\n\r\n    var x = [\r\n      [-1, 0],\r\n      [1, 0],\r\n      [0, 1],\r\n      [0, -1],\r\n    ];\r\n\r\n    for (var i = 0; i < x.length; i++) {\r\n      if (\r\n        p.row + x[i][0] >= 0 &&\r\n        p.row + x[i][0] < 20 &&\r\n        p.col + x[i][1] >= 0 &&\r\n        p.col + x[i][1] < 50 &&\r\n        !grid[p.row + x[i][0]][p.col + x[i][1]].isVisited &&\r\n        !grid[p.row + x[i][0]][p.col + x[i][1]].isWall\r\n      ) {\r\n        q.enqueue(grid[p.row + x[i][0]][p.col + x[i][1]]);\r\n        grid[p.row + x[i][0]][p.col + x[i][1]].isVisited = true;\r\n        grid[p.row + x[i][0]][p.col + x[i][1]].distance =\r\n          grid[p.row][p.col].distance + 1;\r\n\r\n        grid[p.row + x[i][0]][p.col + x[i][1]].previousNode =\r\n          grid[p.row][p.col];\r\n\r\n        console.log(grid[p.row + x[i][0]][p.col + x[i][1]]);\r\n        visitedNodesInOrder.push(grid[p.row + x[i][0]][p.col + x[i][1]]);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nclass Queue {\r\n  constructor() {\r\n    let items = [];\r\n    let front = 0;\r\n    let rear = -1;\r\n    let count = 0;\r\n\r\n    //Add a new element in queue\r\n    this.enqueue = (elm) => {\r\n      items[++rear] = elm;\r\n      count++;\r\n    };\r\n\r\n    //Remove element from the queue\r\n    this.dequeue = () => {\r\n      let current = front++;\r\n      let temp = items[current];\r\n      items[current] = null;\r\n      count--;\r\n      return temp;\r\n    };\r\n\r\n    //Return the first element from the queue\r\n    this.front = () => {\r\n      return items[front];\r\n    };\r\n\r\n    //Return the last element from the queue\r\n    this.rear = () => {\r\n      return items[rear];\r\n    };\r\n\r\n    //Check if queue is empty\r\n    this.isEmpty = () => {\r\n      return count === 0;\r\n    };\r\n\r\n    //Return the size of the queue\r\n    this.size = () => {\r\n      return count;\r\n    };\r\n\r\n    //Print the queue\r\n    this.print = () => {\r\n      let temp = items.filter((e) => e !== null);\r\n      console.log(temp.toString());\r\n    };\r\n  }\r\n}\r\n\r\nexport function getNodesInShortestPathOrderBFS(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    console.log(currentNode);\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    var prenode = currentNode.previousNode;\r\n\r\n    currentNode = currentNode.previousNode;\r\n    console.log(currentNode);\r\n    console.log(prenode);\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function DFS(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  DFSUtil(grid, startNode, finishNode, visitedNodesInOrder);\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction DFSUtil(grid, node, finishNode, visitedNodesInOrder) {\r\n  var p = node;\r\n  node.isVisitedNode = true;\r\n  visitedNodesInOrder.push(p);\r\n\r\n  if (finishNode === node) return 1;\r\n\r\n  // moving right\r\n  if (\r\n    p.col + 1 < 50 &&\r\n    !grid[p.row][p.col + 1].isVisitedNode &&\r\n    !grid[p.row][p.col + 1].isWall\r\n  ) {\r\n    grid[p.row][p.col + 1].previousNode = grid[p.row][p.col];\r\n    if (DFSUtil(grid, grid[p.row][p.col + 1], finishNode, visitedNodesInOrder))\r\n      return 1;\r\n  }\r\n\r\n  // moving up\r\n  if (\r\n    p.row - 1 >= 0 &&\r\n    !grid[p.row - 1][p.col].isVisitedNode &&\r\n    !grid[p.row - 1][p.col].isWall\r\n  ) {\r\n    grid[p.row - 1][p.col].previousNode = grid[p.row][p.col];\r\n    if (DFSUtil(grid, grid[p.row - 1][p.col], finishNode, visitedNodesInOrder))\r\n      return 1;\r\n  }\r\n\r\n  // moving down\r\n  if (\r\n    p.row + 1 < 20 &&\r\n    !grid[p.row + 1][p.col].isVisitedNode &&\r\n    !grid[p.row + 1][p.col].isWall\r\n  ) {\r\n    grid[p.row + 1][p.col].previousNode = grid[p.row][p.col];\r\n    if (DFSUtil(grid, grid[p.row + 1][p.col], finishNode, visitedNodesInOrder))\r\n      return 1;\r\n  }\r\n\r\n  // moving left\r\n  if (\r\n    p.col - 1 >= 0 &&\r\n    !grid[p.row][p.col - 1].isVisitedNode &&\r\n    !grid[p.row][p.col - 1].isWall\r\n  ) {\r\n    grid[p.row][p.col - 1].previousNode = grid[p.row][p.col];\r\n    if (DFSUtil(grid, grid[p.row][p.col - 1], finishNode, visitedNodesInOrder))\r\n      return 1;\r\n  }\r\n}\r\n","export function Astar(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n\r\n  const openSet = [];\r\n  const closedSet = [];\r\n  openSet.push(startNode);\r\n\r\n  startNode.distance = 0;\r\n  while (openSet.length) {\r\n    sortNodesByDistance(openSet); //sort with distance\r\n    const currentNode = openSet.shift();\r\n    closedSet.push(currentNode);\r\n    currentNode.isVisitedNode = true;\r\n\r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    // finally find the goal, trace path with parent\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    const Neighbours = getNeighbors(currentNode, grid);\r\n\r\n    for (var i = 0; i < Neighbours.length; i++) {\r\n      let neighbour = Neighbours[i];\r\n\r\n      if (neighbour.isWall || closedSet.includes(neighbour)) {\r\n        continue;\r\n      }\r\n\r\n      let cost =\r\n        currentNode.distance + heuristic_cost_estimate(currentNode, neighbour);\r\n      console.log(cost);\r\n      console.log(neighbour.distance);\r\n\r\n      if (cost < neighbour.distance || !openSet.includes(neighbour)) {\r\n        neighbour.distance = cost;\r\n        neighbour.hdistance = heuristic_cost_estimate(neighbour, finishNode);\r\n        neighbour.previousNode = currentNode;\r\n\r\n        if (!openSet.includes(neighbour)) {\r\n          openSet.push(neighbour);\r\n          console.log(neighbour);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort(\r\n    (nodeA, nodeB) =>\r\n      nodeA.distance + nodeA.hdistance - (nodeB.distance + nodeB.hdistance)\r\n  );\r\n}\r\n\r\nfunction getNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors;\r\n}\r\n\r\nfunction heuristic_cost_estimate(nodeA, nodeB) {\r\n  const deltaX = Math.abs(nodeA.row - nodeB.row);\r\n  const deltaY = Math.abs(nodeA.col - nodeB.col);\r\n\r\n  return deltaX + deltaY;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    console.log(currentNode);\r\n    console.log(currentNode.isWall);\r\n    console.log(currentNode.previousNode);\r\n\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n    console.log(currentNode);\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function BestFS(grid, startNode, finishNode) {\r\n  var q = [];\r\n\r\n  q.push(startNode);\r\n\r\n  startNode.distance = 0;\r\n  startNode.isVisited = true;\r\n  startNode.previousNode = null;\r\n\r\n  const visitedNodesInOrder = [];\r\n\r\n  while (q.length) {\r\n    var p = q.shift();\r\n\r\n    // Destination found;\r\n    if (grid[p.row][p.col].isFinish) return visitedNodesInOrder;\r\n\r\n    var x = [\r\n      [-1, 0],\r\n      [1, 0],\r\n      [0, 1],\r\n      [0, -1],\r\n    ];\r\n\r\n    for (var i = 0; i < x.length; i++) {\r\n      if (\r\n        p.row + x[i][0] >= 0 &&\r\n        p.row + x[i][0] < 20 &&\r\n        p.col + x[i][1] >= 0 &&\r\n        p.col + x[i][1] < 50 &&\r\n        !grid[p.row + x[i][0]][p.col + x[i][1]].isVisited &&\r\n        !grid[p.row + x[i][0]][p.col + x[i][1]].isWall\r\n      ) {\r\n        q.push(grid[p.row + x[i][0]][p.col + x[i][1]]);\r\n\r\n        grid[p.row + x[i][0]][p.col + x[i][1]].isVisited = true;\r\n        grid[p.row + x[i][0]][p.col + x[i][1]].distance =\r\n          grid[p.row][p.col].distance + 1;\r\n\r\n        grid[p.row + x[i][0]][p.col + x[i][1]].previousNode =\r\n          grid[p.row][p.col];\r\n\r\n        console.log(grid[p.row + x[i][0]][p.col + x[i][1]]);\r\n        visitedNodesInOrder.push(grid[p.row + x[i][0]][p.col + x[i][1]]);\r\n      }\r\n    }\r\n    sortNodesByDistance(q);\r\n  }\r\n}\r\n\r\nexport function getNodesInShortestPathOrderBFS(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    console.log(currentNode);\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    var prenode = currentNode.previousNode;\r\n\r\n    currentNode = currentNode.previousNode;\r\n    console.log(currentNode);\r\n    console.log(prenode);\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n","import React, {Component} from \"react\";\r\nimport {Link} from \"react-router-dom\";\r\nimport \"../main.css\";\r\n\r\nclass Navbar extends Component {\r\n  state = {\r\n    path: \"./\",\r\n  };\r\n  componentDidMount() {\r\n    if (this.props.running) {\r\n      this.setState({path: \" \"});\r\n    } else {\r\n      this.setState({path: \" ./\"});\r\n    }\r\n    console.log(this.state.path);\r\n  }\r\n\r\n  render() {\r\n    let path = this.state.path;\r\n    return (\r\n      <nav className=\"navbar  navbar-light default-color lighten-4\">\r\n        <span className=\"navbar-brand mb-0 h1\">Visulaizer</span>\r\n        <Link\r\n          className=\" Container home \"\r\n          to={{\r\n            pathname: \"./\",\r\n          }}>\r\n          Home\r\n        </Link>\r\n      </nav>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Navbar;\r\n","import React, {Component} from \"react\";\r\nimport \"../PathfindingVisualizer/Node/Node\";\r\n\r\nclass Rules extends Component {\r\n  render() {\r\n    return (\r\n      <div>\r\n        <div className=\"row\">\r\n          <div className=\"col-xs-6\">\r\n            <div className={`node node-start `} style={{margin: \"7px\"}}></div>\r\n          </div>\r\n          <div className=\"col-xs-6\">\r\n            <p style={{padding: \"5px\"}}>Represents Start Node</p>\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"row\">\r\n          <div className=\"col-xs-6\">\r\n            <div className={`node node-wall `} style={{margin: \"7px\"}}></div>\r\n          </div>\r\n          <div className=\"col-xs-6\">\r\n            <p style={{padding: \"5px\"}}>Represents wall</p>\r\n          </div>\r\n        </div>\r\n        <div className=\"row\">\r\n          <div className=\"col-xs-6\">\r\n            <div className={`node node-finish `} style={{margin: \"7px\"}}></div>\r\n          </div>\r\n          <div className=\"col-xs-6\">\r\n            <p style={{padding: \"5px\"}}>Represents Finish Node</p>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Rules;\r\n","import React, {Component} from \"react\";\nimport Node from \"./Node/Node\";\nimport {dijkstra, getNodesInShortestPathOrder} from \"../algorithms/dijkstra\";\nimport {BFS} from \"../algorithms/BFS\";\nimport {DFS} from \"../algorithms/DFS\";\nimport {Astar} from \"../algorithms/Astar\";\nimport {BestFS} from \"../algorithms/BestFS\";\nimport {Redirect} from \"react-router-dom\";\n\nimport Navbar from \"../Pages//Navbar\";\nimport Rules from \"../Pages/Rule\";\n\nimport \"./PathfindingVisualizer.css\";\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\nconst NO_ROWS = 20;\nconst NO_COLS = 50;\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      isRunning: false,\n      algo: [],\n    };\n  }\n\n  componentDidMount() {\n    const grid = getInitialGrid(NO_ROWS, NO_COLS);\n    this.setState({grid});\n    this.state.algo.push(dijkstra);\n    this.state.algo.push(BFS);\n    this.state.algo.push(DFS);\n    this.state.algo.push(Astar);\n    this.state.algo.push(BestFS);\n\n    // const {algo} = this.props.location.state;\n    // console.log(algo);\n  }\n\n  handleMouseDown(row, col) {\n    if (!this.state.isRunning) {\n      const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({grid: newGrid, mouseIsPressed: true});\n    }\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.isRunning) {\n      if (!this.state.mouseIsPressed) return;\n      const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({grid: newGrid});\n    }\n  }\n\n  handleMouseUp() {\n    if (!this.state.isRunning) {\n      this.setState({mouseIsPressed: false});\n    }\n  }\n\n  animate(visitedNodesInOrder, nodesInShortestPathOrder) {\n    if (visitedNodesInOrder.length === null) {\n      this.setState({isRunning: false});\n      return;\n    }\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 5 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        const newGrid = getVisitedGrid(this.state.grid, node.row, node.col);\n        this.setState({grid: newGrid});\n      }, 5 * i);\n    }\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        const newGrid = getShortestpathgrid(\n          this.state.grid,\n          node.row,\n          node.col\n        );\n        this.setState({grid: newGrid});\n      }, 25 * i);\n    }\n    this.setState({isRunning: false});\n  }\n\n  visualize() {\n    if (!this.state.isRunning) {\n      const {algonum} = this.props.location.state;\n      console.log(algonum);\n      const {grid} = this.state;\n      this.setState({isRunning: true});\n      const startNode = grid[START_NODE_ROW][START_NODE_COL];\n      const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n      const visitedNodesInOrder = this.state.algo[algonum](\n        grid,\n        startNode,\n        finishNode\n      );\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\n    }\n  }\n\n  reset() {\n    if (!this.state.isRunning) {\n      const initgridd = getInitialGrid(NO_ROWS, NO_COLS);\n      this.setState({grid: initgridd});\n      this.setState({mouseIsPressed: false});\n      this.setState({isRunning: false});\n    }\n  }\n\n  render() {\n    var style = {\n      position: \"fixed\",\n      top: \"100px\",\n      right: \"50px\",\n    };\n\n    var style1 = {\n      position: \"fixed\",\n      top: \"200px\",\n      right: \"50px\",\n    };\n\n    const grid = this.state.grid;\n    const mouseIsPressed = this.state.mouseIsPressed;\n\n    if (!this.props.location.state) {\n      return <Redirect to={\"/Homepage\"} />;\n    }\n\n    return (\n      <div>\n        <Navbar />\n        <div className=\"rules\">\n          {\" \"}\n          <Rules />\n        </div>\n        <div className=\"h-100 row align-items-center\">\n          <div className=\"grid \">\n            {grid.map((row, rowIdx) => {\n              return (\n                <div key={rowIdx}>\n                  {row.map((node, nodeIdx) => {\n                    const {\n                      row,\n                      col,\n                      isFinish,\n                      isStart,\n                      isWall,\n                      isVisitednode,\n                      isShortestPath,\n                    } = node;\n                    return (\n                      <Node\n                        key={nodeIdx}\n                        col={col}\n                        isFinish={isFinish}\n                        isStart={isStart}\n                        isWall={isWall}\n                        mouseIsPressed={mouseIsPressed}\n                        isVisitednode={isVisitednode}\n                        isShortestPath={isShortestPath}\n                        onMouseDown={(row, col) =>\n                          this.handleMouseDown(row, col)\n                        }\n                        onMouseEnter={(row, col) =>\n                          this.handleMouseEnter(row, col)\n                        }\n                        onMouseUp={() => this.handleMouseUp()}\n                        row={row}></Node>\n                    );\n                  })}\n                </div>\n              );\n            })}\n          </div>\n        </div>\n        <button\n          style={style}\n          onClick={() => this.visualize()}\n          className=\"btn btn-primary\">\n          Visualize\n        </button>\n        <button\n          className=\"btn btn-primary\"\n          style={style1}\n          onClick={() => this.reset()}>\n          Reset\n        </button>\n      </div>\n    );\n  }\n}\n\nconst getInitialGrid = (x, y) => {\n  const grid = [];\n\n  for (let row = 0; row < x; row++) {\n    const currentRow = [];\n    for (let col = 0; col < y; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    hdistance: Infinity,\n    isVisitednode: false,\n    isShortestPath: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getVisitedGrid = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isVisitednode: true,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getShortestpathgrid = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isShortestPath: true,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n","import React, {Component} from \"react\";\r\nimport Navbar from \"./Navbar\";\r\nimport {Link} from \"react-router-dom\";\r\nimport \"../main.css\";\r\n\r\nclass Homepage extends Component {\r\n  state = {};\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"mainhome\">\r\n        <Navbar />\r\n\r\n        <div className=\"row\">\r\n          <div className=\"col\">\r\n            <div className=\"card pathcard shadow p-3 mb-5 bg-white rounded\">\r\n              <div className=\"card-body\">\r\n                <h5 className=\"card-title\">{this.props.title}</h5>\r\n                <p className=\"card-text text-center font-weight-bold\">\r\n                  Path finding algorithms\r\n                </p>\r\n                <ul class=\"list-group list-group-flush\">\r\n                  <li class=\"list-group-item\">\r\n                    {\" \"}\r\n                    <Link\r\n                      className=\" link\"\r\n                      to={{\r\n                        pathname: \"/BFS\",\r\n                      }}>\r\n                      BFS\r\n                    </Link>\r\n                  </li>\r\n                  <li class=\"list-group-item\">\r\n                    <Link\r\n                      className=\"link\"\r\n                      to={{\r\n                        pathname: \"/BestFS\",\r\n                      }}>\r\n                      BestFS\r\n                    </Link>\r\n                  </li>\r\n                  <li class=\"list-group-item\">\r\n                    {\" \"}\r\n                    <Link\r\n                      className=\" link\"\r\n                      to={{\r\n                        pathname: \"/Astar\",\r\n                      }}>\r\n                      Astar\r\n                    </Link>\r\n                  </li>\r\n                  <li class=\"list-group-item\">\r\n                    <Link\r\n                      className=\" link\"\r\n                      to={{\r\n                        pathname: \"/Dijkstra\",\r\n                      }}>\r\n                      Dijkstra\r\n                    </Link>\r\n                  </li>\r\n                  <li class=\"list-group-item\">\r\n                    <Link\r\n                      className=\" link\"\r\n                      to={{\r\n                        pathname: \"/DFS\",\r\n                      }}>\r\n                      DFS\r\n                    </Link>\r\n                  </li>\r\n                </ul>\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div className=\"col\">\r\n            <div className=\"card  sortingcard shadow p-3 mb-5 bg-white rounded\">\r\n              <div className=\"card-body\">\r\n                <h5 className=\"card-title\">{this.props.title}</h5>\r\n                <p className=\"card-text text-center font-weight-bold\">\r\n                  Sorting algorithms\r\n                </p>\r\n\r\n                <ul class=\"list-group list-group-flush\">\r\n                  <li class=\"list-group-item\">\r\n                    <Link\r\n                      className=\" link\"\r\n                      to={{\r\n                        pathname: \"/MergeSort\",\r\n                      }}>\r\n                      MergeSort\r\n                    </Link>\r\n                  </li>\r\n                  <li class=\"list-group-item\">\r\n                    <Link\r\n                      className=\" link\"\r\n                      to={{\r\n                        pathname: \"/BubbleSort\",\r\n                      }}>\r\n                      BubbleSort\r\n                    </Link>\r\n                  </li>\r\n                  <li class=\"list-group-item\">\r\n                    <Link\r\n                      className=\" link\"\r\n                      to={{\r\n                        pathname: \"./QuickSort\",\r\n                      }}>\r\n                      QuickSort\r\n                    </Link>\r\n                  </li>\r\n                  <li class=\"list-group-item\">\r\n                    {\" \"}\r\n                    <Link\r\n                      className=\" link\"\r\n                      to={{\r\n                        pathname: \"./InsertionSort\",\r\n                      }}>\r\n                      InsertionSort\r\n                    </Link>\r\n                  </li>\r\n                </ul>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Homepage;\r\n","export function getMergeSortAnimations(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  const auxiliaryArray = array.slice();\n  mergeSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\n  return animations;\n}\n\nfunction mergeSortHelper(\n  mainArray,\n  startIdx,\n  endIdx,\n  auxiliaryArray,\n  animations,\n) {\n  if (startIdx === endIdx) return;\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\n  mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\n  mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\n  doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\n}\n\nfunction doMerge(\n  mainArray,\n  startIdx,\n  middleIdx,\n  endIdx,\n  auxiliaryArray,\n  animations,\n) {\n  let k = startIdx;\n  let i = startIdx;\n  let j = middleIdx + 1;\n  while (i <= middleIdx && j <= endIdx) {\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([i, j]);\n    // These are the values that we're comparing; we push them a second\n    // time to revert their color.\n    animations.push([i, j]);\n    if (auxiliaryArray[i] <= auxiliaryArray[j]) {\n      // We overwrite the value at index k in the original array with the\n      // value at index i in the auxiliary array.\n      animations.push([k, auxiliaryArray[i]]);\n      mainArray[k++] = auxiliaryArray[i++];\n    } else {\n      // We overwrite the value at index k in the original array with the\n      // value at index j in the auxiliary array.\n      animations.push([k, auxiliaryArray[j]]);\n      mainArray[k++] = auxiliaryArray[j++];\n    }\n  }\n  while (i <= middleIdx) {\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([i, i]);\n    // These are the values that we're comparing; we push them a second\n    // time to revert their color.\n    animations.push([i, i]);\n    // We overwrite the value at index k in the original array with the\n    // value at index i in the auxiliary array.\n    animations.push([k, auxiliaryArray[i]]);\n    mainArray[k++] = auxiliaryArray[i++];\n  }\n  while (j <= endIdx) {\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([j, j]);\n    // These are the values that we're comparing; we push them a second\n    // time to revert their color.\n    animations.push([j, j]);\n    // We overwrite the value at index k in the original array with the\n    // value at index j in the auxiliary array.\n    animations.push([k, auxiliaryArray[j]]);\n    mainArray[k++] = auxiliaryArray[j++];\n  }\n}\n","export function quickSort(array) {\r\n  const animations = [];\r\n  const low = 0;\r\n  const high = array.length - 1;\r\n  quickSorthelper(array, low, high, animations);\r\n  return animations;\r\n}\r\n\r\nexport function quickSorthelper(array, low, high, animations) {\r\n  if (low < high) {\r\n    /* pi is partitioning index, arr[pi] is now\r\n           at right place */\r\n    let pi = partition(array, low, high, animations);\r\n\r\n    quickSorthelper(array, low, pi - 1, animations); // Before pi\r\n    quickSorthelper(array, pi + 1, high, animations); // After pi\r\n  }\r\n}\r\n\r\nexport function partition(array, low, high, animations) {\r\n  // pivot (Element to be placed at right position)\r\n  let pivot = array[high];\r\n\r\n  let i = low - 1; // Index of smaller element\r\n\r\n  for (let j = low; j <= high - 1; j++) {\r\n    animations.push([j, high, 1]);\r\n    animations.push([j, high, 2]);\r\n    // If current element is smaller than the pivot\r\n    if (array[j] < pivot) {\r\n      i++; // increment index of smaller element\r\n\r\n      let k = array[j];\r\n      array[j] = array[i];\r\n      array[i] = k;\r\n      animations.push([i, j, 0]);\r\n      //swap arr[i] and arr[j]\r\n    }\r\n  }\r\n  animations.push([i + 1, high, 0]);\r\n  let k = array[high];\r\n  array[high] = array[i + 1];\r\n  array[i + 1] = k;\r\n  // swap arr[i + 1] and arr[high])\r\n  return i + 1;\r\n}\r\n","import React from \"react\";\nimport {getMergeSortAnimations} from \"../sortingAlgorithms/sortingAlgorithms.js\";\nimport \"./SortingVisualizer.css\";\nimport Navbar from \"../Pages//Navbar\";\nimport {quickSort} from \"../sortingAlgorithms/Quicksort\";\nimport {InsertionSort} from \"../sortingAlgorithms/InsertionSort\";\nimport {BubbleSort} from \"../sortingAlgorithms/Bubblesort\";\nimport {Redirect} from \"react-router-dom\";\n\n// Change this value for the speed of the animations.\nconst ANIMATION_SPEED_MS = 1;\n\n// Change this value for the number of bars (value) in the array.\nconst NUMBER_OF_ARRAY_BARS = 300;\n\n// This is the main color of the array bars.\nconst PRIMARY_COLOR = \"turquoise\";\n\n// This is the color of array bars that are being compared throughout the animations.\nconst SECONDARY_COLOR = \"red\";\n\nexport default class SortingVisualizer extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      array: [],\n      running: false,\n    };\n  }\n\n  componentDidMount() {\n    this.resetArray();\n  }\n\n  resetArray() {\n    const array = [];\n    for (let i = 0; i < NUMBER_OF_ARRAY_BARS; i++) {\n      array.push(randomIntFromInterval(5, 600));\n    }\n    this.setState({array});\n  }\n\n  sort() {\n    const {algonum} = this.props.location.state;\n    console.log(algonum);\n    if (algonum === 0) this.mergeSort();\n    else if (algonum === 1) this.quickSort();\n    else if (algonum === 2) this.Inserion();\n    else this.bubbleSort();\n  }\n\n  mergeSort() {\n    console.log(\"doing merge sort\");\n    const animations = getMergeSortAnimations(this.state.array);\n    for (let i = 0; i < animations.length; i++) {\n      const arrayBars = document.getElementsByClassName(\"array-bar\");\n      const isColorChange = i % 3 !== 2;\n      if (isColorChange) {\n        const [barOneIdx, barTwoIdx] = animations[i];\n        const barOneStyle = arrayBars[barOneIdx].style;\n        const barTwoStyle = arrayBars[barTwoIdx].style;\n        const color = i % 3 === 0 ? SECONDARY_COLOR : PRIMARY_COLOR;\n        setTimeout(() => {\n          barOneStyle.backgroundColor = color;\n          barTwoStyle.backgroundColor = color;\n        }, i * ANIMATION_SPEED_MS);\n      } else {\n        setTimeout(() => {\n          const barOneIdx = animations[i][0];\n          const newHeight = animations[i][1];\n          const barOneStyle = arrayBars[barOneIdx].style;\n          barOneStyle.height = `${newHeight}px`;\n        }, i * ANIMATION_SPEED_MS);\n      }\n    }\n  }\n\n  Inserion() {\n    console.log(\"doing Isertio sort sort\");\n    console.log(this.state.array);\n    const animations = InsertionSort(this.state.array);\n    console.log(this.state.array);\n    console.log(animations);\n    for (let i = 0; i < animations.length; i++) {\n      const arrayBars = document.getElementsByClassName(\"array-bar\");\n      if (animations[i][2]) {\n        const barOneIdx = animations[i][0];\n        const barTwoIdx = animations[i][1];\n        const barOneStyle = arrayBars[barOneIdx].style;\n        const barTwoStyle = arrayBars[barTwoIdx].style;\n        let color;\n\n        if (animations[i][2] === 1) color = SECONDARY_COLOR;\n        else color = PRIMARY_COLOR;\n        setTimeout(() => {\n          barOneStyle.backgroundColor = color;\n          barTwoStyle.backgroundColor = color;\n        }, i * ANIMATION_SPEED_MS);\n      } else {\n        setTimeout(() => {\n          const barOneIdx = animations[i][0];\n          const newHeight = animations[i][1];\n          const barOneStyle = arrayBars[barOneIdx].style;\n          barOneStyle.height = `${newHeight}px`;\n        }, i * ANIMATION_SPEED_MS);\n      }\n    }\n  }\n\n  quickSort() {\n    this.setState({running: true});\n    console.log(\"doing quick sort\");\n    console.log(this.state.array);\n    const animations = quickSort(this.state.array);\n    console.log(this.state.array);\n\n    console.log(animations);\n    for (let i = 0; i < animations.length; i++) {\n      const arrayBars = document.getElementsByClassName(\"array-bar\");\n      if (animations[i][2]) {\n        const barOneIdx = animations[i][0];\n        const barTwoIdx = animations[i][1];\n        const barOneStyle = arrayBars[barOneIdx].style;\n        const barTwoStyle = arrayBars[barTwoIdx].style;\n        let color;\n\n        if (animations[i][2] === 1) color = SECONDARY_COLOR;\n        else color = PRIMARY_COLOR;\n        setTimeout(() => {\n          barOneStyle.backgroundColor = color;\n          barTwoStyle.backgroundColor = color;\n        }, i * ANIMATION_SPEED_MS);\n      } else {\n        setTimeout(() => {\n          const barOneIdx = animations[i][0];\n          const barTwoIdx = animations[i][1];\n\n          const barOneStyle = arrayBars[barOneIdx].style;\n          const barTwoStyle = arrayBars[barTwoIdx].style;\n          const l = barOneStyle.height;\n          const r = barTwoStyle.height;\n\n          barOneStyle.height = `${r}`;\n          barTwoStyle.height = `${l}`;\n        }, i * ANIMATION_SPEED_MS);\n      }\n    }\n  }\n\n  heapSort() {\n    // We leave it as an exercise to the viewer of this code to implement this method.\n  }\n\n  bubbleSort() {\n    console.log(\"doing Bubble sort\");\n    console.log(this.state.array);\n    const animations = BubbleSort(this.state.array);\n    console.log(this.state.array);\n\n    console.log(animations);\n    for (let i = 0; i < animations.length; i++) {\n      const arrayBars = document.getElementsByClassName(\"array-bar\");\n      if (!arrayBars) return;\n      if (animations[i][2]) {\n        const barOneIdx = animations[i][0];\n        const barTwoIdx = animations[i][1];\n\n        const barOneStyle = arrayBars[barOneIdx].style;\n        const barTwoStyle = arrayBars[barTwoIdx].style;\n        let color;\n\n        if (animations[i][2] === 1) color = SECONDARY_COLOR;\n        else color = PRIMARY_COLOR;\n        setTimeout(() => {\n          barOneStyle.backgroundColor = color;\n          barTwoStyle.backgroundColor = color;\n        }, i * ANIMATION_SPEED_MS);\n      } else {\n        setTimeout(() => {\n          const barOneIdx = animations[i][0];\n          const barTwoIdx = animations[i][1];\n          const barOneStyle = arrayBars[barOneIdx].style;\n          const barTwoStyle = arrayBars[barTwoIdx].style;\n          const l = barOneStyle.height;\n          const r = barTwoStyle.height;\n\n          barOneStyle.height = `${r}`;\n          barTwoStyle.height = `${l}`;\n        }, i * ANIMATION_SPEED_MS);\n      }\n    }\n  }\n\n  render() {\n    const {array} = this.state;\n    if (!this.props.location.state) {\n      return <Redirect to={\"/Homepage\"} />;\n    }\n    var style = {\n      position: \"fixed\",\n      top: \"100px\",\n      right: \"50px\",\n    };\n\n    var style1 = {\n      position: \"fixed\",\n      top: \"200px\",\n      right: \"50px\",\n    };\n\n    return (\n      <div className=\"visualizepage\">\n        <Navbar running=\"{this.state.running}\" />\n\n        <div className=\"array-container visualizecontainer \">\n          {array.map((value, idx) => (\n            <div\n              className=\"array-bar\"\n              key={idx}\n              style={{\n                backgroundColor: PRIMARY_COLOR,\n                height: `${value}px`,\n              }}></div>\n          ))}\n\n          <button\n            style={style}\n            className=\"btn btn-primary link1 \"\n            onClick={() => this.resetArray()}>\n            Generate New Array\n          </button>\n          <button\n            style={style1}\n            className=\"btn btn-primary link2 \"\n            onClick={() => this.sort()}>\n            Sort\n          </button>\n        </div>\n      </div>\n    );\n  }\n}\n\nfunction randomIntFromInterval(min, max) {\n  // min and max included\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n","export function InsertionSort(arr, low, high) {\r\n  const animations = [];\r\n\r\n  let i;\r\n  let key;\r\n  for (i = 1; i < arr.length; i++) {\r\n    key = arr[i];\r\n    let j = i - 1;\r\n\r\n    while (j >= 0) {\r\n      animations.push([j, i, 1]);\r\n      animations.push([j, i, 2]);\r\n\r\n      if (arr[j] > key) {\r\n        animations.push([j + 1, arr[j], 0]);\r\n        arr[j + 1] = arr[j];\r\n        j = j - 1;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    animations.push([j + 1, key, 0]);\r\n    arr[j + 1] = key;\r\n  }\r\n\r\n  return animations;\r\n}\r\n","export function BubbleSort(arr) {\r\n  const animations = [];\r\n\r\n  let i;\r\n  let j;\r\n  for (i = 1; i < arr.length; i++) {\r\n    for (j = 0; j < arr.length - i; j++) {\r\n      animations.push([j, j + 1, 1]);\r\n      animations.push([j, j + 1, 2]);\r\n      if (arr[j] > arr[j + 1]) {\r\n        animations.push([j, j + 1, 0]);\r\n        let k = arr[j];\r\n        arr[j] = arr[j + 1];\r\n        arr[j + 1] = k;\r\n      }\r\n    }\r\n  }\r\n\r\n  return animations;\r\n}\r\n","import React, {Component} from \"react\";\r\nimport {Link} from \"react-router-dom\";\r\nimport Navbar from \"../Pages/Navbar\";\r\nimport \"../main.css\";\r\nimport {Redirect} from \"react-router-dom\";\r\nimport SyntaxHighlighter from \"react-syntax-highlighter\";\r\nimport {docco} from \"react-syntax-highlighter/dist/esm/styles/hljs\";\r\n\r\nclass BFS extends Component {\r\n  state = {};\r\n\r\n  render() {\r\n    const codeString = `\r\n    export function BFS(grid, startNode, finishNode) {\r\n        var q = new Queue();\r\n      \r\n        q.enqueue(startNode);\r\n      \r\n        startNode.distance = 0;\r\n        startNode.isVisited = true;\r\n        startNode.previousNode = null;\r\n      \r\n        const visitedNodesInOrder = [];\r\n      \r\n        while (!q.isEmpty()) {\r\n          var p = q.front();\r\n      \r\n          q.dequeue();\r\n      \r\n          // Destination found;\r\n          if (grid[p.row][p.col].isFinish) return visitedNodesInOrder;\r\n      \r\n          var x = [\r\n            [-1, 0],\r\n            [1, 0],\r\n            [0, 1],\r\n            [0, -1],\r\n          ];\r\n      \r\n          for (var i = 0; i < x.length; i++) {\r\n            if (\r\n              p.row + x[i][0] >= 0 &&\r\n              p.row + x[i][0] < 20 &&\r\n              p.col + x[i][1] >= 0 &&\r\n              p.col + x[i][1] < 50 &&\r\n              !grid[p.row + x[i][0]][p.col + x[i][1]].isVisited &&\r\n              !grid[p.row + x[i][0]][p.col + x[i][1]].isWall\r\n            ) {\r\n              q.enqueue(grid[p.row + x[i][0]][p.col + x[i][1]]);\r\n              grid[p.row + x[i][0]][p.col + x[i][1]].isVisited = true;\r\n              grid[p.row + x[i][0]][p.col + x[i][1]].distance =\r\n                grid[p.row][p.col].distance + 1;\r\n      \r\n              grid[p.row + x[i][0]][p.col + x[i][1]].previousNode =\r\n                grid[p.row][p.col];\r\n      \r\n              console.log(grid[p.row + x[i][0]][p.col + x[i][1]]);\r\n              visitedNodesInOrder.push(grid[p.row + x[i][0]][p.col + x[i][1]]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n`;\r\n    var style = {\r\n      position: \"fixed\",\r\n      top: \"100px\",\r\n      right: \"50px\",\r\n    };\r\n\r\n    return (\r\n      <div>\r\n        <Navbar />\r\n        <div className=\"\">\r\n          <div className=\"row\">\r\n            <div className=\"col-5 float-left\">\r\n              <div className=\"CodeBLock\">\r\n                <p className=\"text-center font-weight-bold\">Code</p>\r\n                <SyntaxHighlighter language=\"javascript\" style={docco}>\r\n                  {codeString}\r\n                </SyntaxHighlighter>\r\n              </div>\r\n            </div>\r\n\r\n            <div className=\"col-5 \">\r\n              <div className=\"Explanation\">\r\n                <p className=\"text-center font-weight-bold\">Explanation</p>\r\n                <ol>\r\n                  <li>\r\n                    Store each cell as a node with their row, column values and\r\n                    distance from source cell and previou n\r\n                  </li>\r\n                  <li>Start BFS with source cell.</li>\r\n                  <li>\r\n                    Mark the source node as visted and make distance equal to 0\r\n                  </li>\r\n                  <li>\r\n                    Keep updating distance from source value in each move. and\r\n                    Store previous node\r\n                  </li>\r\n                  <li>\r\n                    Return distance when destination is met, else return -1 (no\r\n                    path exists in between source and destination).\r\n                  </li>\r\n                </ol>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        <Link\r\n          className=\" btn btn-primary\"\r\n          style={style}\r\n          to={{\r\n            pathname: \"./PathfindingVisualizer\",\r\n            state: {\r\n              algonum: 1,\r\n            },\r\n          }}>\r\n          Visualize BFS\r\n        </Link>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default BFS;\r\n","import React, {Component} from \"react\";\r\nimport {Link} from \"react-router-dom\";\r\nimport Navbar from \"../Pages/Navbar\";\r\nimport \"../main.css\";\r\nimport {Redirect} from \"react-router-dom\";\r\nimport SyntaxHighlighter from \"react-syntax-highlighter\";\r\nimport {docco} from \"react-syntax-highlighter/dist/esm/styles/hljs\";\r\n\r\nclass BFS extends Component {\r\n  state = {};\r\n\r\n  render() {\r\n    const codeString = `\r\n    export function DFS(grid, startNode, finishNode) {\r\n        const visitedNodesInOrder = [];\r\n        DFSUtil(grid, startNode, finishNode, visitedNodesInOrder);\r\n        return visitedNodesInOrder;\r\n      }\r\n      \r\n      function DFSUtil(grid, node, finishNode, visitedNodesInOrder) {\r\n        var p = node;\r\n        node.isVisitedNode = true;\r\n        visitedNodesInOrder.push(p);\r\n      \r\n        if (finishNode === node) return 1;\r\n      \r\n        // moving right\r\n        if (\r\n          p.col + 1 < 50 &&\r\n          !grid[p.row][p.col + 1].isVisitedNode &&\r\n          !grid[p.row][p.col + 1].isWall\r\n        ) {\r\n          grid[p.row][p.col + 1].previousNode = grid[p.row][p.col];\r\n          if (DFSUtil(grid, grid[p.row][p.col + 1], finishNode, visitedNodesInOrder))\r\n            return 1;\r\n        }\r\n      \r\n        // moving up\r\n        if (\r\n          p.row - 1 >= 0 &&\r\n          !grid[p.row - 1][p.col].isVisitedNode &&\r\n          !grid[p.row - 1][p.col].isWall\r\n        ) {\r\n          grid[p.row - 1][p.col].previousNode = grid[p.row][p.col];\r\n          if (DFSUtil(grid, grid[p.row - 1][p.col], finishNode, visitedNodesInOrder))\r\n            return 1;\r\n        }\r\n      \r\n        // moving down\r\n        if (\r\n          p.row + 1 < 20 &&\r\n          !grid[p.row + 1][p.col].isVisitedNode &&\r\n          !grid[p.row + 1][p.col].isWall\r\n        ) {\r\n          grid[p.row + 1][p.col].previousNode = grid[p.row][p.col];\r\n          if (DFSUtil(grid, grid[p.row + 1][p.col], finishNode, visitedNodesInOrder))\r\n            return 1;\r\n        }\r\n      \r\n        // moving left\r\n        if (\r\n          p.col - 1 >= 0 &&\r\n          !grid[p.row][p.col - 1].isVisitedNode &&\r\n          !grid[p.row][p.col - 1].isWall\r\n        ) {\r\n          grid[p.row][p.col - 1].previousNode = grid[p.row][p.col];\r\n          if (DFSUtil(grid, grid[p.row][p.col - 1], finishNode, visitedNodesInOrder))\r\n            return 1;\r\n        }\r\n      }\r\n      \r\n`;\r\n    var style = {\r\n      position: \"fixed\",\r\n      top: \"100px\",\r\n      right: \"50px\",\r\n    };\r\n\r\n    return (\r\n      <div>\r\n        <Navbar />\r\n        <div className=\"\">\r\n          <div className=\"row\">\r\n            <div className=\"col-5 float-left\">\r\n              <div className=\"CodeBLock\">\r\n                <p className=\"text-center font-weight-bold\">Code</p>\r\n                <SyntaxHighlighter language=\"cpp\" style={docco}>\r\n                  {codeString}\r\n                </SyntaxHighlighter>\r\n              </div>\r\n            </div>\r\n\r\n            <div className=\"col-5 \">\r\n              <div className=\"Explanation\">\r\n                <p className=\"text-center font-weight-bold\">Explanation</p>\r\n                <ol>\r\n                  <li>\r\n                    Store each cell as a node with their row, column values and\r\n                    distance from source cell.\r\n                  </li>\r\n                  <li>Start BFS with source cell.</li>\r\n                  <li>\r\n                    Make a visited array with all having false values except\r\n                    0cells which are assigned true values as they can not be\r\n                    traversed.\r\n                  </li>\r\n                  <li>\r\n                    Keep updating distance from source value in each move.\r\n                  </li>\r\n                  <li>\r\n                    Return distance when destination is met, else return -1 (no\r\n                    path exists in between source and destination).\r\n                  </li>\r\n                </ol>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        <Link\r\n          className=\" btn btn-primary\"\r\n          style={style}\r\n          to={{\r\n            pathname: \"./PathfindingVisualizer\",\r\n            state: {\r\n              algonum: 2,\r\n            },\r\n          }}>\r\n          Visualize DFS\r\n        </Link>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default BFS;\r\n","import React, {Component} from \"react\";\r\nimport {Link} from \"react-router-dom\";\r\nimport Navbar from \"../Pages/Navbar\";\r\nimport \"../main.css\";\r\nimport {Redirect} from \"react-router-dom\";\r\nimport SyntaxHighlighter from \"react-syntax-highlighter\";\r\nimport {docco} from \"react-syntax-highlighter/dist/esm/styles/hljs\";\r\n\r\nclass BFS extends Component {\r\n  state = {};\r\n\r\n  render() {\r\n    const codeString = `\r\n    export function Astar(grid, startNode, finishNode) {\r\n        const visitedNodesInOrder = [];\r\n      \r\n        const openSet = [];\r\n        const closedSet = [];\r\n        openSet.push(startNode);\r\n      \r\n        startNode.distance = 0;\r\n        while (openSet.length) {\r\n          sortNodesByDistance(openSet); //sort with distance\r\n          const currentNode = openSet.shift();\r\n          closedSet.push(currentNode);\r\n          currentNode.isVisitedNode = true;\r\n      \r\n          visitedNodesInOrder.push(currentNode);\r\n      \r\n          // finally find the goal, trace path with parent\r\n          if (currentNode === finishNode) {\r\n            return visitedNodesInOrder;\r\n          }\r\n      \r\n          const Neighbours = getNeighbors(currentNode, grid);\r\n      \r\n          for (var i = 0; i < Neighbours.length; i++) {\r\n            let neighbour = Neighbours[i];\r\n      \r\n            if (neighbour.isWall || closedSet.includes(neighbour)) {\r\n              continue;\r\n            }\r\n      \r\n            let cost =\r\n              currentNode.distance + heuristic_cost_estimate(currentNode, neighbour);\r\n            console.log(cost);\r\n            console.log(neighbour.distance);\r\n      \r\n            if (cost < neighbour.distance || !openSet.includes(neighbour)) {\r\n              neighbour.distance = cost;\r\n              neighbour.hdistance = heuristic_cost_estimate(neighbour, finishNode);\r\n              neighbour.previousNode = currentNode;\r\n      \r\n              if (!openSet.includes(neighbour)) {\r\n                openSet.push(neighbour);\r\n                console.log(neighbour);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      function sortNodesByDistance(unvisitedNodes) {\r\n        unvisitedNodes.sort(\r\n          (nodeA, nodeB) =>\r\n            nodeA.distance + nodeA.hdistance - (nodeB.distance + nodeB.hdistance)\r\n        );\r\n      }\r\n      \r\n      function getNeighbors(node, grid) {\r\n        const neighbors = [];\r\n        const {col, row} = node;\r\n        if (row > 0) neighbors.push(grid[row - 1][col]);\r\n        if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n        if (col > 0) neighbors.push(grid[row][col - 1]);\r\n        if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n        return neighbors;\r\n      }\r\n      \r\n      function heuristic_cost_estimate(nodeA, nodeB) {\r\n        const deltaX = Math.abs(nodeA.row - nodeB.row);\r\n        const deltaY = Math.abs(nodeA.col - nodeB.col);\r\n      \r\n        return deltaX + deltaY;\r\n      }\r\n      \r\n      // Backtracks from the finishNode to find the shortest path.\r\n      // Only works when called *after* the dijkstra method above.\r\n      export function getNodesInShortestPathOrder(finishNode) {\r\n        const nodesInShortestPathOrder = [];\r\n        let currentNode = finishNode;\r\n        while (currentNode !== null) {\r\n          console.log(currentNode);\r\n          console.log(currentNode.isWall);\r\n          console.log(currentNode.previousNode);\r\n      \r\n          nodesInShortestPathOrder.unshift(currentNode);\r\n          currentNode = currentNode.previousNode;\r\n          console.log(currentNode);\r\n        }\r\n        return nodesInShortestPathOrder;\r\n      }\r\n      \r\n`;\r\n    var style = {\r\n      position: \"fixed\",\r\n      top: \"100px\",\r\n      right: \"50px\",\r\n    };\r\n\r\n    return (\r\n      <div>\r\n        <Navbar />\r\n        <div className=\"\">\r\n          <div className=\"row\">\r\n            <div className=\"col-5 float-left\">\r\n              <div className=\"CodeBLock\">\r\n                <p className=\"text-center font-weight-bold\">Code</p>\r\n                <SyntaxHighlighter language=\"cpp\" style={docco}>\r\n                  {codeString}\r\n                </SyntaxHighlighter>\r\n              </div>\r\n            </div>\r\n\r\n            <div className=\"col-5 \">\r\n              <div className=\"Explanation\">\r\n                <p className=\"text-center font-weight-bold\">Explanation</p>\r\n                <div>\r\n                  <h6>What is A* Search Algorithm? </h6>\r\n                  <div>\r\n                    A* Search algorithm is one of the best and popular technique\r\n                    used in path-finding and graph traversals.{\" \"}\r\n                  </div>\r\n                  <h6>Why A* Search Algorithm ?</h6>\r\n                  <div>\r\n                    Informally speaking, A* Search algorithms, unlike other\r\n                    traversal techniques, it has brains. What it means is that\r\n                    it is really a smart algorithm which separates it from the\r\n                    other conventional algorithms. This fact is cleared in\r\n                    detail in below sections. And it is also worth mentioning\r\n                    that many games and web-based maps use this algorithm to\r\n                    find the shortest path very efficiently (approximation).\r\n                  </div>\r\n                </div>\r\n                2a9d8f\r\n                <ol>\r\n                  <li>\r\n                    Store each cell as a node with their row, column values and\r\n                    distance from source cell.\r\n                  </li>\r\n                  <li>Start BFS with source cell.</li>\r\n                  <li>\r\n                    Make a visited array with all having false values except\r\n                    0cells which are assigned true values as they can not be\r\n                    traversed.\r\n                  </li>\r\n                  <li>\r\n                    Keep updating distance from source value in each move.\r\n                  </li>\r\n                  <li>\r\n                    Return distance when destination is met, else return -1 (no\r\n                    path exists in between source and destination).\r\n                  </li>\r\n                </ol>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        <Link\r\n          className=\" btn btn-primary\"\r\n          style={style}\r\n          to={{\r\n            pathname: \"./PathfindingVisualizer\",\r\n            state: {\r\n              algonum: 3,\r\n            },\r\n          }}>\r\n          Visualize Astar\r\n        </Link>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default BFS;\r\n","import React, {Component} from \"react\";\r\nimport {Link} from \"react-router-dom\";\r\nimport Navbar from \"../Pages/Navbar\";\r\nimport \"../main.css\";\r\nimport {Redirect} from \"react-router-dom\";\r\nimport SyntaxHighlighter from \"react-syntax-highlighter\";\r\nimport {docco} from \"react-syntax-highlighter/dist/esm/styles/hljs\";\r\n\r\nclass BFS extends Component {\r\n  state = {};\r\n\r\n  render() {\r\n    const codeString = `\r\n    export function BestFS(grid, startNode, finishNode) {\r\n        var q = [];\r\n      \r\n        q.push(startNode);\r\n      \r\n        startNode.distance = 0;\r\n        startNode.isVisited = true;\r\n        startNode.previousNode = null;\r\n      \r\n        const visitedNodesInOrder = [];\r\n      \r\n        while (q.length) {\r\n          var p = q.shift();\r\n      \r\n          // Destination found;\r\n          if (grid[p.row][p.col].isFinish) return visitedNodesInOrder;\r\n      \r\n          var x = [\r\n            [-1, 0],\r\n            [1, 0],\r\n            [0, 1],\r\n            [0, -1],\r\n          ];\r\n      \r\n          for (var i = 0; i < x.length; i++) {\r\n            if (\r\n              p.row + x[i][0] >= 0 &&\r\n              p.row + x[i][0] < 20 &&\r\n              p.col + x[i][1] >= 0 &&\r\n              p.col + x[i][1] < 50 &&\r\n              !grid[p.row + x[i][0]][p.col + x[i][1]].isVisited &&\r\n              !grid[p.row + x[i][0]][p.col + x[i][1]].isWall\r\n            ) {\r\n              q.push(grid[p.row + x[i][0]][p.col + x[i][1]]);\r\n      \r\n              grid[p.row + x[i][0]][p.col + x[i][1]].isVisited = true;\r\n              grid[p.row + x[i][0]][p.col + x[i][1]].distance =\r\n                grid[p.row][p.col].distance + 1;\r\n      \r\n              grid[p.row + x[i][0]][p.col + x[i][1]].previousNode =\r\n                grid[p.row][p.col];\r\n      \r\n              console.log(grid[p.row + x[i][0]][p.col + x[i][1]]);\r\n              visitedNodesInOrder.push(grid[p.row + x[i][0]][p.col + x[i][1]]);\r\n            }\r\n          }\r\n          sortNodesByDistance(q);\r\n        }\r\n      }\r\n      \r\n      export function getNodesInShortestPathOrderBFS(finishNode) {\r\n        const nodesInShortestPathOrder = [];\r\n        let currentNode = finishNode;\r\n        while (currentNode !== null) {\r\n          console.log(currentNode);\r\n          nodesInShortestPathOrder.unshift(currentNode);\r\n          var prenode = currentNode.previousNode;\r\n      \r\n          currentNode = currentNode.previousNode;\r\n          console.log(currentNode);\r\n          console.log(prenode);\r\n        }\r\n        return nodesInShortestPathOrder;\r\n      }\r\n      function sortNodesByDistance(unvisitedNodes) {\r\n        unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n      }\r\n      \r\n`;\r\n    var style = {\r\n      position: \"fixed\",\r\n      top: \"100px\",\r\n      right: \"50px\",\r\n    };\r\n\r\n    return (\r\n      <div>\r\n        <Navbar />\r\n        <div className=\"\">\r\n          <div className=\"row\">\r\n            <div className=\"col-5 float-left\">\r\n              <div className=\"CodeBLock\">\r\n                <p className=\"text-center font-weight-bold\">Code</p>\r\n                <SyntaxHighlighter language=\"javascript\" style={docco}>\r\n                  {codeString}\r\n                </SyntaxHighlighter>\r\n              </div>\r\n            </div>\r\n\r\n            <div className=\"col-5 \">\r\n              <div className=\"Explanation\">\r\n                <p className=\"text-center font-weight-bold\">Explanation</p>\r\n                <div>\r\n                  Best-First-Search(Grah g, Node start)\r\n                  <p>Create an empty PriorityQueue PriorityQueue pq;</p>\r\n                  <p> Until PriorityQueue is empty</p>\r\n                  <p> u = PriorityQueue.DeleteMin</p>\r\n                  <p></p>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        <Link\r\n          className=\" btn btn-primary\"\r\n          style={style}\r\n          to={{\r\n            pathname: \"./PathfindingVisualizer\",\r\n            state: {\r\n              algonum: 4,\r\n            },\r\n          }}>\r\n          Visualize BestFS\r\n        </Link>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default BFS;\r\n","import React, {Component} from \"react\";\r\nimport {Link} from \"react-router-dom\";\r\nimport Navbar from \"../Pages/Navbar\";\r\nimport \"../main.css\";\r\nimport {Redirect} from \"react-router-dom\";\r\nimport SyntaxHighlighter from \"react-syntax-highlighter\";\r\nimport {docco} from \"react-syntax-highlighter/dist/esm/styles/hljs\";\r\n\r\nclass BFS extends Component {\r\n  state = {};\r\n\r\n  render() {\r\n    const codeString = `\r\n    int ShortestPath(char grid[N][M]) \r\n{ \r\n    QItem source(0, 0, 0); \r\n  \r\n    // To keep track of visited QItems. Marking \r\n    // blocked cells as visited. \r\n    bool visited[N][M]; \r\n    for (int i = 0; i < N; i++) { \r\n        for (int j = 0; j < M; j++) \r\n        { \r\n            if (grid[i][j] == '0') \r\n                visited[i][j] = true; \r\n            else\r\n                visited[i][j] = false; \r\n  \r\n            // Finding source \r\n            if (grid[i][j] == 's') \r\n            { \r\n               source.row = i; \r\n               source.col = j; \r\n            } \r\n        } \r\n    } \r\n  \r\n    // applying BFS on matrix cells starting from source \r\n    queue<QItem> q; \r\n    q.push(source); \r\n    visited[source.row][source.col] = true; \r\n    while (!q.empty()) { \r\n        QItem p = q.front(); \r\n        q.pop(); \r\n  \r\n        // Destination found; \r\n        if (grid[p.row][p.col] == 'd') \r\n            return p.dist; \r\n  \r\n        // moving up \r\n        if (p.row - 1 >= 0 && \r\n            visited[p.row - 1][p.col] == false) { \r\n            q.push(QItem(p.row - 1, p.col, p.dist + 1)); \r\n            visited[p.row - 1][p.col] = true; \r\n        } \r\n  \r\n        // moving down \r\n        if (p.row + 1 < N && \r\n            visited[p.row + 1][p.col] == false) { \r\n            q.push(QItem(p.row + 1, p.col, p.dist + 1)); \r\n            visited[p.row + 1][p.col] = true; \r\n        } \r\n  \r\n        // moving left \r\n        if (p.col - 1 >= 0 && \r\n            visited[p.row][p.col - 1] == false) { \r\n            q.push(QItem(p.row, p.col - 1, p.dist + 1)); \r\n            visited[p.row][p.col - 1] = true; \r\n        } \r\n  \r\n         // moving right \r\n        if (p.col + 1 < M && \r\n            visited[p.row][p.col + 1] == false) { \r\n            q.push(QItem(p.row, p.col + 1, p.dist + 1)); \r\n            visited[p.row][p.col + 1] = true; \r\n        } \r\n    } \r\n    return -1; \r\n} \r\n`;\r\n    var style = {\r\n      position: \"fixed\",\r\n      top: \"100px\",\r\n      right: \"50px\",\r\n    };\r\n\r\n    return (\r\n      <div>\r\n        <Navbar />\r\n        <div className=\"\">\r\n          <div className=\"row\">\r\n            <div className=\"col-5 float-left\">\r\n              <div className=\"CodeBLock\">\r\n                <p className=\"text-center font-weight-bold\">Code</p>\r\n                <SyntaxHighlighter language=\"cpp\" style={docco}>\r\n                  {codeString}\r\n                </SyntaxHighlighter>\r\n              </div>\r\n            </div>\r\n\r\n            <div className=\"col-5 \">\r\n              <div className=\"Explanation\">\r\n                <p className=\"text-center font-weight-bold\">Explanation</p>\r\n                <ol>\r\n                  <li>\r\n                    Store each cell as a node with their row, column values and\r\n                    distance from source cell.\r\n                  </li>\r\n                  <li>Start BFS with source cell.</li>\r\n                  <li>\r\n                    Make a visited array with all having false values except\r\n                    0cells which are assigned true values as they can not be\r\n                    traversed.\r\n                  </li>\r\n                  <li>\r\n                    Keep updating distance from source value in each move.\r\n                  </li>\r\n                  <li>\r\n                    Return distance when destination is met, else return -1 (no\r\n                    path exists in between source and destination).\r\n                  </li>\r\n                </ol>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        <Link\r\n          className=\" btn btn-primary\"\r\n          style={style}\r\n          to={{\r\n            pathname: \"./PathfindingVisualizer\",\r\n            state: {\r\n              algonum: 0,\r\n            },\r\n          }}>\r\n          Visualize Dijktra\r\n        </Link>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default BFS;\r\n","import React, {Component} from \"react\";\r\nimport {Link} from \"react-router-dom\";\r\nimport Navbar from \"../Pages/Navbar\";\r\nimport \"../main.css\";\r\nimport {Redirect} from \"react-router-dom\";\r\nimport SyntaxHighlighter from \"react-syntax-highlighter\";\r\nimport {docco} from \"react-syntax-highlighter/dist/esm/styles/hljs\";\r\n\r\nclass BFS extends Component {\r\n  state = {};\r\n\r\n  render() {\r\n    const codeString = `\r\n    // C++ program for implementation of Bubble sort \r\n    #include <bits/stdc++.h> \r\n    using namespace std; \r\n    \r\n    void swap(int *xp, int *yp) \r\n    { \r\n        int temp = *xp; \r\n        *xp = *yp; \r\n        *yp = temp; \r\n    } \r\n    \r\n    // A function to implement bubble sort \r\n    void bubbleSort(int arr[], int n) \r\n    { \r\n        int i, j; \r\n        for (i = 0; i < n-1; i++)\t \r\n        \r\n        // Last i elements are already in place \r\n        for (j = 0; j < n-i-1; j++) \r\n            if (arr[j] > arr[j+1]) \r\n                swap(&arr[j], &arr[j+1]); \r\n    } \r\n    \r\n    /* Function to print an array */\r\n    void printArray(int arr[], int size) \r\n    { \r\n        int i; \r\n        for (i = 0; i < size; i++) \r\n            cout << arr[i] << \" \"; \r\n        cout << endl; \r\n    } \r\n    \r\n    // Driver code \r\n    int main() \r\n    { \r\n        int arr[] = {64, 34, 25, 12, 22, 11, 90}; \r\n        int n = sizeof(arr)/sizeof(arr[0]); \r\n        bubbleSort(arr, n); \r\n        cout<<\"Sorted array: \\n\"; \r\n        printArray(arr, n); \r\n        return 0; \r\n    } \r\n    \r\n`;\r\n    var style = {\r\n      position: \"fixed\",\r\n      top: \"100px\",\r\n      right: \"50px\",\r\n    };\r\n\r\n    return (\r\n      <div>\r\n        <Navbar />\r\n        <div className=\"\">\r\n          <div className=\"row\">\r\n            <div className=\"col-5 float-left\">\r\n              <div className=\"CodeBLock\">\r\n                <p className=\"text-center font-weight-bold\">Code</p>\r\n                <SyntaxHighlighter language=\"cpp\" style={docco}>\r\n                  {codeString}\r\n                </SyntaxHighlighter>\r\n              </div>\r\n            </div>\r\n\r\n            <div className=\"col-5 \">\r\n              <div className=\"Explanation\">\r\n                <p className=\"text-center font-weight-bold\">Explanation</p>\r\n                <p>\r\n                  Bubble Sort is the simplest sorting algorithm that works by\r\n                  repeatedly swapping the adjacent elements if they are in wrong\r\n                  order.\r\n                </p>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        <Link\r\n          className=\" btn btn-primary\"\r\n          style={style}\r\n          to={{\r\n            pathname: \"./Sorting\",\r\n            state: {\r\n              algonum: 3,\r\n            },\r\n          }}>\r\n          Visualize Bubble Sort\r\n        </Link>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default BFS;\r\n","import React, {Component} from \"react\";\r\nimport {Link} from \"react-router-dom\";\r\nimport Navbar from \"../Pages/Navbar\";\r\nimport \"../main.css\";\r\nimport {Redirect} from \"react-router-dom\";\r\nimport SyntaxHighlighter from \"react-syntax-highlighter\";\r\nimport {docco} from \"react-syntax-highlighter/dist/esm/styles/hljs\";\r\n\r\nclass BFS extends Component {\r\n  state = {};\r\n\r\n  render() {\r\n    const codeString = `\r\n    /* C++ implementation of QuickSort */\r\n    #include <bits/stdc++.h> \r\n    using namespace std; \r\n    \r\n    // A utility function to swap two elements \r\n    void swap(int* a, int* b) \r\n    { \r\n        int t = *a; \r\n        *a = *b; \r\n        *b = t; \r\n    } \r\n    \r\n    /* This function takes last element as pivot, places \r\n    the pivot element at its correct position in sorted \r\n    array, and places all smaller (smaller than pivot) \r\n    to left of pivot and all greater elements to right \r\n    of pivot */\r\n    int partition (int arr[], int low, int high) \r\n    { \r\n        int pivot = arr[high]; // pivot \r\n        int i = (low - 1); // Index of smaller element \r\n    \r\n        for (int j = low; j <= high - 1; j++) \r\n        { \r\n            // If current element is smaller than the pivot \r\n            if (arr[j] < pivot) \r\n            { \r\n                i++; // increment index of smaller element \r\n                swap(&arr[i], &arr[j]); \r\n            } \r\n        } \r\n        swap(&arr[i + 1], &arr[high]); \r\n        return (i + 1); \r\n    } \r\n    \r\n    /* The main function that implements QuickSort \r\n    arr[] --> Array to be sorted, \r\n    low --> Starting index, \r\n    high --> Ending index */\r\n    void quickSort(int arr[], int low, int high) \r\n    { \r\n        if (low < high) \r\n        { \r\n            /* pi is partitioning index, arr[p] is now \r\n            at right place */\r\n            int pi = partition(arr, low, high); \r\n    \r\n            // Separately sort elements before \r\n            // partition and after partition \r\n            quickSort(arr, low, pi - 1); \r\n            quickSort(arr, pi + 1, high); \r\n        } \r\n    } \r\n    \r\n    /* Function to print an array */\r\n    void printArray(int arr[], int size) \r\n    { \r\n        int i; \r\n        for (i = 0; i < size; i++) \r\n            cout << arr[i] << \" \"; \r\n        cout << endl; \r\n    } \r\n    \r\n    // Driver Code \r\n    int main() \r\n    { \r\n        int arr[] = {10, 7, 8, 9, 1, 5}; \r\n        int n = sizeof(arr) / sizeof(arr[0]); \r\n        quickSort(arr, 0, n - 1); \r\n        cout << \"Sorted array: \\n\"; \r\n        printArray(arr, n); \r\n        return 0; \r\n    } \r\n    \r\n    // This code is contributed by rathbhupendra \r\n    \r\n`;\r\n    var style = {\r\n      position: \"fixed\",\r\n      top: \"100px\",\r\n      right: \"50px\",\r\n    };\r\n\r\n    return (\r\n      <div>\r\n        <Navbar />\r\n        <div className=\"\">\r\n          <div className=\"row\">\r\n            <div className=\"col-5 float-left\">\r\n              <div className=\"CodeBLock\">\r\n                <p className=\"text-center font-weight-bold\">Code</p>\r\n                <SyntaxHighlighter language=\"cpp\" style={docco}>\r\n                  {codeString}\r\n                </SyntaxHighlighter>\r\n              </div>\r\n            </div>\r\n\r\n            <div className=\"col-5 \">\r\n              <div className=\"Explanation\">\r\n                <p className=\"text-center font-weight-bold\">Explanation</p>\r\n                <p>\r\n                  Like Merge Sort, QuickSort is a Divide and Conquer algorithm.\r\n                  It picks an element as pivot and partitions the given array\r\n                  around the picked pivot. There are many different versions of\r\n                  quickSort that pick pivot in different ways.We use last\r\n                  element as pivot\r\n                </p>\r\n                <p>\r\n                  The key process in quickSort is partition(). Target of\r\n                  partitions is, given an array and an element x of array as\r\n                  pivot, put x at its correct position in sorted array and put\r\n                  all smaller elements (smaller than x) before x, and put all\r\n                  greater elements (greater than x) after x. All this should be\r\n                  done in linear time.\r\n                </p>\r\n                <h6>Partition Algorithm </h6>\r\n                <p>\r\n                  There can be many ways to do partition, following pseudo code\r\n                  adopts the method given in CLRS book. The logic is simple, we\r\n                  start from the leftmost element and keep track of index of\r\n                  smaller (or equal to) elements as i. While traversing, if we\r\n                  find a smaller element, we swap current element with arr[i].\r\n                  Otherwise we ignore current element.\r\n                </p>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        <Link\r\n          className=\" btn btn-primary\"\r\n          style={style}\r\n          to={{\r\n            pathname: \"./Sorting\",\r\n            state: {\r\n              algonum: 1,\r\n            },\r\n          }}>\r\n          Visualize Quick Sort\r\n        </Link>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default BFS;\r\n","import React, {Component} from \"react\";\r\nimport {Link} from \"react-router-dom\";\r\nimport Navbar from \"../Pages/Navbar\";\r\nimport \"../main.css\";\r\nimport {Redirect} from \"react-router-dom\";\r\nimport SyntaxHighlighter from \"react-syntax-highlighter\";\r\nimport {docco} from \"react-syntax-highlighter/dist/esm/styles/hljs\";\r\n\r\nclass BFS extends Component {\r\n  state = {};\r\n\r\n  render() {\r\n    const codeString = `\r\n    /* C program for Merge Sort */\r\n    #include <stdio.h> \r\n    #include <stdlib.h> \r\n    \r\n    // Merges two subarrays of arr[]. \r\n    // First subarray is arr[l..m] \r\n    // Second subarray is arr[m+1..r] \r\n    void merge(int arr[], int l, int m, int r) \r\n    { \r\n        int i, j, k; \r\n        int n1 = m - l + 1; \r\n        int n2 = r - m; \r\n    \r\n        /* create temp arrays */\r\n        int L[n1], R[n2]; \r\n    \r\n        /* Copy data to temp arrays L[] and R[] */\r\n        for (i = 0; i < n1; i++) \r\n            L[i] = arr[l + i]; \r\n        for (j = 0; j < n2; j++) \r\n            R[j] = arr[m + 1 + j]; \r\n    \r\n        /* Merge the temp arrays back into arr[l..r]*/\r\n        i = 0; // Initial index of first subarray \r\n        j = 0; // Initial index of second subarray \r\n        k = l; // Initial index of merged subarray \r\n        while (i < n1 && j < n2) { \r\n            if (L[i] <= R[j]) { \r\n                arr[k] = L[i]; \r\n                i++; \r\n            } \r\n            else { \r\n                arr[k] = R[j]; \r\n                j++; \r\n            } \r\n            k++; \r\n        } \r\n    \r\n        /* Copy the remaining elements of L[], if there \r\n        are any */\r\n        while (i < n1) { \r\n            arr[k] = L[i]; \r\n            i++; \r\n            k++; \r\n        } \r\n    \r\n        /* Copy the remaining elements of R[], if there \r\n        are any */\r\n        while (j < n2) { \r\n            arr[k] = R[j]; \r\n            j++; \r\n            k++; \r\n        } \r\n    } \r\n    \r\n    /* l is for left index and r is right index of the \r\n    sub-array of arr to be sorted */\r\n    void mergeSort(int arr[], int l, int r) \r\n    { \r\n        if (l < r) { \r\n            // Same as (l+r)/2, but avoids overflow for \r\n            // large l and h \r\n            int m = l + (r - l) / 2; \r\n    \r\n            // Sort first and second halves \r\n            mergeSort(arr, l, m); \r\n            mergeSort(arr, m + 1, r); \r\n    \r\n            merge(arr, l, m, r); \r\n        } \r\n    } \r\n    \r\n    /* UTILITY FUNCTIONS */\r\n    /* Function to print an array */\r\n    void printArray(int A[], int size) \r\n    { \r\n        int i; \r\n        for (i = 0; i < size; i++) \r\n            printf(\"%d \", A[i]); \r\n        printf(\"\\n\"); \r\n    } \r\n    \r\n    /* Driver program to test above functions */\r\n    int main() \r\n    { \r\n        int arr[] = { 12, 11, 13, 5, 6, 7 }; \r\n        int arr_size = sizeof(arr) / sizeof(arr[0]); \r\n    \r\n        printf(\"Given array is \\n\"); \r\n        printArray(arr, arr_size); \r\n    \r\n        mergeSort(arr, 0, arr_size - 1); \r\n    \r\n        printf(\"\\nSorted array is \\n\"); \r\n        printArray(arr, arr_size); \r\n        return 0; \r\n    } \r\n    \r\n    \r\n`;\r\n    var style = {\r\n      position: \"fixed\",\r\n      top: \"100px\",\r\n      right: \"50px\",\r\n    };\r\n\r\n    return (\r\n      <div>\r\n        <Navbar />\r\n        <div className=\"\">\r\n          <div className=\"row\">\r\n            <div className=\"col-5 float-left\">\r\n              <div className=\"CodeBLock\">\r\n                <p className=\"text-center font-weight-bold\">Code</p>\r\n                <SyntaxHighlighter language=\"cpp\" style={docco}>\r\n                  {codeString}\r\n                </SyntaxHighlighter>\r\n              </div>\r\n            </div>\r\n\r\n            <div className=\"col-5 \">\r\n              <div className=\"Explanation\">\r\n                <p className=\"text-center font-weight-bold\">Explanation</p>\r\n                <p>\r\n                  Like QuickSort, Merge Sort is a Divide and Conquer algorithm.\r\n                  It divides input array in two halves, calls itself for the two\r\n                  halves and then merges the two sorted halves. The merge()\r\n                  function is used for merging two halves. The merge(arr, l, m,\r\n                  r) is key process that assumes that arr[l..m] and arr[m+1..r]\r\n                  are sorted and merges the two sorted sub-arrays into one. See\r\n                  following C implementation for details.\r\n                </p>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        <Link\r\n          className=\" btn btn-primary\"\r\n          style={style}\r\n          to={{\r\n            pathname: \"./Sorting\",\r\n            state: {\r\n              algonum: 0,\r\n            },\r\n          }}>\r\n          Visualize Merge Sort\r\n        </Link>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default BFS;\r\n","import React, {Component} from \"react\";\r\nimport {Link} from \"react-router-dom\";\r\nimport Navbar from \"../Pages/Navbar\";\r\nimport \"../main.css\";\r\nimport {Redirect} from \"react-router-dom\";\r\nimport SyntaxHighlighter from \"react-syntax-highlighter\";\r\nimport {docco} from \"react-syntax-highlighter/dist/esm/styles/hljs\";\r\n\r\nclass BFS extends Component {\r\n  state = {};\r\n\r\n  render() {\r\n    const codeString = `\r\n    // C++ program for insertion sort \r\n    #include <bits/stdc++.h> \r\n    using namespace std; \r\n    \r\n    /* Function to sort an array using insertion sort*/\r\n    void insertionSort(int arr[], int n) \r\n    { \r\n        int i, key, j; \r\n        for (i = 1; i < n; i++) \r\n        { \r\n            key = arr[i]; \r\n            j = i - 1; \r\n    \r\n            /* Move elements of arr[0..i-1], that are \r\n            greater than key, to one position ahead \r\n            of their current position */\r\n            while (j >= 0 && arr[j] > key) \r\n            { \r\n                arr[j + 1] = arr[j]; \r\n                j = j - 1; \r\n            } \r\n            arr[j + 1] = key; \r\n        } \r\n    } \r\n    \r\n    // A utility function to print an array of size n \r\n    void printArray(int arr[], int n) \r\n    { \r\n        int i; \r\n        for (i = 0; i < n; i++) \r\n            cout << arr[i] << \" \"; \r\n        cout << endl; \r\n    } \r\n    \r\n    /* Driver code */\r\n    int main() \r\n    { \r\n        int arr[] = { 12, 11, 13, 5, 6 }; \r\n        int n = sizeof(arr) / sizeof(arr[0]); \r\n    \r\n        insertionSort(arr, n); \r\n        printArray(arr, n); \r\n    \r\n        return 0; \r\n    } \r\n    \r\n    // This is code is contributed by rathbhupendra \r\n    \r\n    \r\n`;\r\n    var style = {\r\n      position: \"fixed\",\r\n      top: \"100px\",\r\n      right: \"50px\",\r\n    };\r\n\r\n    return (\r\n      <div>\r\n        <Navbar />\r\n        <div className=\"\">\r\n          <div className=\"row\">\r\n            <div className=\"col-5 float-left\">\r\n              <div className=\"CodeBLock\">\r\n                <p className=\"text-center font-weight-bold\">Code</p>\r\n                <SyntaxHighlighter language=\"cpp\" style={docco}>\r\n                  {codeString}\r\n                </SyntaxHighlighter>\r\n              </div>\r\n            </div>\r\n\r\n            <div className=\"col-5 \">\r\n              <div className=\"Explanation\">\r\n                <p className=\"text-center font-weight-bold\">Explanation</p>\r\n                <p>\r\n                  Bubble Sort is the simplest sorting algorithm that works by\r\n                  repeatedly swapping the adjacent elements if they are in wrong\r\n                  order.\r\n                </p>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        <Link\r\n          className=\" btn btn-primary\"\r\n          style={style}\r\n          to={{\r\n            pathname: \"./Sorting\",\r\n            state: {\r\n              algonum: 2,\r\n            },\r\n          }}>\r\n          Visualize Insertion Sort\r\n        </Link>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default BFS;\r\n","import React, {Component} from \"react\";\nimport \"./App.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\nimport Homepage from \"./Pages/Homepage\";\nimport {Route} from \"react-router-dom\";\nimport {HashRouter as Router} from \"react-router-dom\";\nimport SortingVisualizer from \"./SortingVisualizer/SortingVisualizer\";\nimport BFS from \"./PathFindingPages/BFS\";\nimport DFS from \"./PathFindingPages/DFS\";\nimport Astar from \"./PathFindingPages/Astar\";\nimport BestFS from \"./PathFindingPages/BestFS\";\nimport Dijkstra from \"./PathFindingPages/Dijkstra\";\nimport BubbleSort from \"./SortAlgorithmPages/BubbleSort\";\nimport QuickSort from \"./SortAlgorithmPages/QuickSort\";\nimport MergeSort from \"./SortAlgorithmPages/MergeSort\";\nimport InsertionSort from \"./SortAlgorithmPages/InsertionSort\";\n\nclass App extends Component {\n  state = {};\n\n  render() {\n    return (\n      <Router basename=\"/\">\n        <Route path=\"/\" exact component={Homepage} />\n        <Route\n          path=\"/PathfindingVisualizer\"\n          component={PathfindingVisualizer}\n        />\n        <Route path=\"/Homepage\" component={Homepage} />\n        <Route path=\"/Sorting\" component={SortingVisualizer} />\n        <Route path=\"/BFS\" component={BFS} />\n        <Route path=\"/DFS\" component={DFS} />\n        <Route path=\"/BestFS\" component={BestFS} />\n        <Route path=\"/Astar\" component={Astar} />\n        <Route path=\"/Dijkstra\" component={Dijkstra} />\n        <Route path=\"/MergeSort\" component={MergeSort} />\n        <Route path=\"/QuickSort\" component={QuickSort} />\n        <Route path=\"/BubbleSort\" component={BubbleSort} />\n        <Route path=\"/InsertionSort\" component={InsertionSort} />\n      </Router>\n      // <SortingVisualizer></SortingVisualizer>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport \"bootstrap/dist/css/bootstrap.css\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}