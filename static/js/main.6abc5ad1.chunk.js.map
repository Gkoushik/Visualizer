{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","algorithms/BFS.js","algorithms/DFS.js","algorithms/Astar.js","algorithms/BestFS.js","Pages/Rule.jsx","Pages/Navbar.jsx","PathfindingVisualizer/PathfindingVisualizer.jsx","Pages/Code.jsx","Pages/Content.jsx","Pages/Homepage.jsx","sortingAlgorithms/sortingAlgorithms.js","sortingAlgorithms/Quicksort.js","SortingVisualizer/SortingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","isVisitednode","isShortestPath","extraClassName","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","BFS","q","Queue","enqueue","isEmpty","p","front","dequeue","x","i","console","log","items","rear","count","elm","current","temp","size","print","e","toString","DFS","DFSUtil","isVisitedNode","Astar","openSet","closedSet","hdistance","currentNode","Neighbours","getNeighbors","neighbour","includes","cost","heuristic_cost_estimate","Math","abs","BestFS","Rules","class","style","margin","padding","Navbar","state","to","pathname","PathfindingVisualizer","mouseIsPressed","isRunning","algo","getInitialGrid","setState","newGrid","getNewGridWithWallToggled","nodesInShortestPathOrder","setTimeout","animateShortestPath","getVisitedGrid","getShortestpathgrid","algonum","location","unshift","getNodesInShortestPathOrder","animate","initgridd","Rule","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","onClick","visualize","reset","y","currentRow","createNode","slice","newNode","Code","Content","title","refs","tag","Homepage","tags","sortingalgos","getMergeSortAnimations","array","animations","auxiliaryArray","mergeSortHelper","mainArray","startIdx","endIdx","middleIdx","floor","k","j","doMerge","quickSort","quickSorthelper","low","high","pi","pivot","partition","SortingVisualizer","resetArray","min","max","random","mergeSort","arrayBars","document","getElementsByClassName","barOneIdx","barTwoIdx","barOneStyle","barTwoStyle","color","backgroundColor","newHeight","height","l","r","value","idx","React","App","basename","path","exact","component","Boolean","window","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.6abc5ad1.chunk.js","sourcesContent":["import React, {Component} from \"react\";\n\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      row,\n      isVisitednode,\n      isShortestPath,\n    } = this.props;\n\n    const extraClassName = isFinish\n      ? \"node-finish\"\n      : isStart\n      ? \"node-start\"\n      : isWall\n      ? \"node-wall\"\n      : isShortestPath\n      ? \"node-shortest-path\"\n      : isVisitednode\n      ? \"node-visited\"\n      : \"\";\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}  `}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}></div>\n    );\n  }\n}\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const {col, row} = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    console.log(currentNode);\n    console.log(currentNode.isWall);\n    console.log(currentNode.previousNode);\n\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n    console.log(currentNode);\n  }\n  return nodesInShortestPathOrder;\n}\n","export function BFS(grid, startNode, finishNode) {\r\n  var q = new Queue();\r\n\r\n  q.enqueue(startNode);\r\n\r\n  startNode.distance = 0;\r\n  startNode.isVisited = true;\r\n  startNode.previousNode = null;\r\n\r\n  const visitedNodesInOrder = [];\r\n\r\n  while (!q.isEmpty()) {\r\n    var p = q.front();\r\n\r\n    q.dequeue();\r\n\r\n    // Destination found;\r\n    if (grid[p.row][p.col].isFinish) return visitedNodesInOrder;\r\n\r\n    var x = [\r\n      [-1, 0],\r\n      [1, 0],\r\n      [0, 1],\r\n      [0, -1],\r\n    ];\r\n\r\n    for (var i = 0; i < x.length; i++) {\r\n      if (\r\n        p.row + x[i][0] >= 0 &&\r\n        p.row + x[i][0] < 20 &&\r\n        p.col + x[i][1] >= 0 &&\r\n        p.col + x[i][1] < 50 &&\r\n        !grid[p.row + x[i][0]][p.col + x[i][1]].isVisited &&\r\n        !grid[p.row + x[i][0]][p.col + x[i][1]].isWall\r\n      ) {\r\n        q.enqueue(grid[p.row + x[i][0]][p.col + x[i][1]]);\r\n        grid[p.row + x[i][0]][p.col + x[i][1]].isVisited = true;\r\n        grid[p.row + x[i][0]][p.col + x[i][1]].distance =\r\n          grid[p.row][p.col].distance + 1;\r\n\r\n        grid[p.row + x[i][0]][p.col + x[i][1]].previousNode =\r\n          grid[p.row][p.col];\r\n\r\n        console.log(grid[p.row + x[i][0]][p.col + x[i][1]]);\r\n        visitedNodesInOrder.push(grid[p.row + x[i][0]][p.col + x[i][1]]);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nclass Queue {\r\n  constructor() {\r\n    let items = [];\r\n    let front = 0;\r\n    let rear = -1;\r\n    let count = 0;\r\n\r\n    //Add a new element in queue\r\n    this.enqueue = (elm) => {\r\n      items[++rear] = elm;\r\n      count++;\r\n    };\r\n\r\n    //Remove element from the queue\r\n    this.dequeue = () => {\r\n      let current = front++;\r\n      let temp = items[current];\r\n      items[current] = null;\r\n      count--;\r\n      return temp;\r\n    };\r\n\r\n    //Return the first element from the queue\r\n    this.front = () => {\r\n      return items[front];\r\n    };\r\n\r\n    //Return the last element from the queue\r\n    this.rear = () => {\r\n      return items[rear];\r\n    };\r\n\r\n    //Check if queue is empty\r\n    this.isEmpty = () => {\r\n      return count === 0;\r\n    };\r\n\r\n    //Return the size of the queue\r\n    this.size = () => {\r\n      return count;\r\n    };\r\n\r\n    //Print the queue\r\n    this.print = () => {\r\n      let temp = items.filter((e) => e !== null);\r\n      console.log(temp.toString());\r\n    };\r\n  }\r\n}\r\n\r\nexport function getNodesInShortestPathOrderBFS(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    console.log(currentNode);\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    var prenode = currentNode.previousNode;\r\n\r\n    currentNode = currentNode.previousNode;\r\n    console.log(currentNode);\r\n    console.log(prenode);\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function DFS(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  DFSUtil(grid, startNode, finishNode, visitedNodesInOrder);\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction DFSUtil(grid, node, finishNode, visitedNodesInOrder) {\r\n  var p = node;\r\n  node.isVisitedNode = true;\r\n  visitedNodesInOrder.push(p);\r\n\r\n  if (finishNode === node) return 1;\r\n\r\n  // moving right\r\n  if (\r\n    p.col + 1 < 50 &&\r\n    !grid[p.row][p.col + 1].isVisitedNode &&\r\n    !grid[p.row][p.col + 1].isWall\r\n  ) {\r\n    grid[p.row][p.col + 1].previousNode = grid[p.row][p.col];\r\n    if (DFSUtil(grid, grid[p.row][p.col + 1], finishNode, visitedNodesInOrder))\r\n      return 1;\r\n  }\r\n\r\n  // moving up\r\n  if (\r\n    p.row - 1 >= 0 &&\r\n    !grid[p.row - 1][p.col].isVisitedNode &&\r\n    !grid[p.row - 1][p.col].isWall\r\n  ) {\r\n    grid[p.row - 1][p.col].previousNode = grid[p.row][p.col];\r\n    if (DFSUtil(grid, grid[p.row - 1][p.col], finishNode, visitedNodesInOrder))\r\n      return 1;\r\n  }\r\n\r\n  // moving down\r\n  if (\r\n    p.row + 1 < 20 &&\r\n    !grid[p.row + 1][p.col].isVisitedNode &&\r\n    !grid[p.row + 1][p.col].isWall\r\n  ) {\r\n    grid[p.row + 1][p.col].previousNode = grid[p.row][p.col];\r\n    if (DFSUtil(grid, grid[p.row + 1][p.col], finishNode, visitedNodesInOrder))\r\n      return 1;\r\n  }\r\n\r\n  // moving left\r\n  if (\r\n    p.col - 1 >= 0 &&\r\n    !grid[p.row][p.col - 1].isVisitedNode &&\r\n    !grid[p.row][p.col - 1].isWall\r\n  ) {\r\n    grid[p.row][p.col - 1].previousNode = grid[p.row][p.col];\r\n    if (DFSUtil(grid, grid[p.row][p.col - 1], finishNode, visitedNodesInOrder))\r\n      return 1;\r\n  }\r\n}\r\n","export function Astar(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n\r\n  const openSet = [];\r\n  const closedSet = [];\r\n  openSet.push(startNode);\r\n\r\n  startNode.distance = 0;\r\n  while (openSet.length) {\r\n    sortNodesByDistance(openSet); //sort with distance\r\n    const currentNode = openSet.shift();\r\n    closedSet.push(currentNode);\r\n    currentNode.isVisitedNode = true;\r\n\r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    // finally find the goal, trace path with parent\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    const Neighbours = getNeighbors(currentNode, grid);\r\n\r\n    for (var i = 0; i < Neighbours.length; i++) {\r\n      let neighbour = Neighbours[i];\r\n\r\n      if (neighbour.isWall || closedSet.includes(neighbour)) {\r\n        continue;\r\n      }\r\n\r\n      let cost =\r\n        currentNode.distance + heuristic_cost_estimate(currentNode, neighbour);\r\n      console.log(cost);\r\n      console.log(neighbour.distance);\r\n\r\n      if (cost < neighbour.distance || !openSet.includes(neighbour)) {\r\n        neighbour.distance = cost;\r\n        neighbour.hdistance = heuristic_cost_estimate(neighbour, finishNode);\r\n        neighbour.previousNode = currentNode;\r\n\r\n        if (!openSet.includes(neighbour)) {\r\n          openSet.push(neighbour);\r\n          console.log(neighbour);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort(\r\n    (nodeA, nodeB) =>\r\n      nodeA.distance + nodeA.hdistance - (nodeB.distance + nodeB.hdistance)\r\n  );\r\n}\r\n\r\nfunction getNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors;\r\n}\r\n\r\nfunction heuristic_cost_estimate(nodeA, nodeB) {\r\n  const deltaX = Math.abs(nodeA.row - nodeB.row);\r\n  const deltaY = Math.abs(nodeA.col - nodeB.col);\r\n\r\n  return deltaX + deltaY;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    console.log(currentNode);\r\n    console.log(currentNode.isWall);\r\n    console.log(currentNode.previousNode);\r\n\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n    console.log(currentNode);\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function BestFS(grid, startNode, finishNode) {\r\n  var q = [];\r\n\r\n  q.push(startNode);\r\n\r\n  startNode.distance = 0;\r\n  startNode.isVisited = true;\r\n  startNode.previousNode = null;\r\n\r\n  const visitedNodesInOrder = [];\r\n\r\n  while (q.length) {\r\n    var p = q.shift();\r\n\r\n    // Destination found;\r\n    if (grid[p.row][p.col].isFinish) return visitedNodesInOrder;\r\n\r\n    var x = [\r\n      [-1, 0],\r\n      [1, 0],\r\n      [0, 1],\r\n      [0, -1],\r\n    ];\r\n\r\n    for (var i = 0; i < x.length; i++) {\r\n      if (\r\n        p.row + x[i][0] >= 0 &&\r\n        p.row + x[i][0] < 20 &&\r\n        p.col + x[i][1] >= 0 &&\r\n        p.col + x[i][1] < 50 &&\r\n        !grid[p.row + x[i][0]][p.col + x[i][1]].isVisited &&\r\n        !grid[p.row + x[i][0]][p.col + x[i][1]].isWall\r\n      ) {\r\n        q.push(grid[p.row + x[i][0]][p.col + x[i][1]]);\r\n\r\n        grid[p.row + x[i][0]][p.col + x[i][1]].isVisited = true;\r\n        grid[p.row + x[i][0]][p.col + x[i][1]].distance =\r\n          grid[p.row][p.col].distance + 1;\r\n\r\n        grid[p.row + x[i][0]][p.col + x[i][1]].previousNode =\r\n          grid[p.row][p.col];\r\n\r\n        console.log(grid[p.row + x[i][0]][p.col + x[i][1]]);\r\n        visitedNodesInOrder.push(grid[p.row + x[i][0]][p.col + x[i][1]]);\r\n      }\r\n    }\r\n    sortNodesByDistance(q);\r\n  }\r\n}\r\n\r\nexport function getNodesInShortestPathOrderBFS(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    console.log(currentNode);\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    var prenode = currentNode.previousNode;\r\n\r\n    currentNode = currentNode.previousNode;\r\n    console.log(currentNode);\r\n    console.log(prenode);\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n","import React, {Component} from \"react\";\r\nimport \"../PathfindingVisualizer/Node/Node\";\r\n\r\nclass Rules extends Component {\r\n  render() {\r\n    return (\r\n      <div class=\"container\">\r\n        <div class=\"row\">\r\n          <div class=\"col-sm\">\r\n            <div class=\"row\">\r\n              <div class=\"col-xs-6\">\r\n                <div\r\n                  className={`node node-start `}\r\n                  style={{margin: \"7px\"}}></div>\r\n              </div>\r\n              <div class=\"col-xs-6\">\r\n                <p style={{padding: \"5px\"}}>Represents Start Node</p>\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div class=\"col-sm\">\r\n            <div class=\"row\">\r\n              <div class=\"col-xs-6\">\r\n                <div\r\n                  className={`node node-finish `}\r\n                  style={{margin: \"7px\"}}></div>\r\n              </div>\r\n              <div class=\"col-xs-6\">\r\n                <p style={{padding: \"5px\"}}>Represents Finish Node</p>\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div class=\"col-sm\">\r\n            <div class=\"row\">\r\n              <div class=\"col-xs-6\">\r\n                <div\r\n                  className={`node node-wall `}\r\n                  style={{margin: \"7px\"}}></div>\r\n              </div>\r\n              <div class=\"col-xs-6\">\r\n                <p style={{padding: \"5px\"}}>Represents wall</p>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Rules;\r\n","import React, {Component} from \"react\";\r\nimport {Link} from \"react-router-dom\";\r\nimport Rules from \"./Rule\";\r\n\r\nclass Navbar extends Component {\r\n  state = {};\r\n  render() {\r\n    return (\r\n      <nav class=\"navbar navbar-light bg-light\">\r\n        <span class=\"navbar-brand mb-0 h1\">Visulaizer</span>\r\n\r\n        <Link\r\n          className=\"container\"\r\n          to={{\r\n            pathname: \"/\",\r\n          }}>\r\n          Home\r\n        </Link>\r\n      </nav>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Navbar;\r\n","import React, {Component} from \"react\";\nimport Node from \"./Node/Node\";\nimport {dijkstra, getNodesInShortestPathOrder} from \"../algorithms/dijkstra\";\nimport {BFS} from \"../algorithms/BFS\";\nimport {DFS} from \"../algorithms/DFS\";\nimport {Astar} from \"../algorithms/Astar\";\nimport {BestFS} from \"../algorithms/BestFS\";\n\nimport Navbar from \"../Pages//Navbar\";\nimport Rules from \"../Pages/Rule\";\n\nimport \"./PathfindingVisualizer.css\";\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\nconst NO_ROWS = 20;\nconst NO_COLS = 50;\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      isRunning: false,\n      algo: [],\n    };\n  }\n\n  componentDidMount() {\n    const grid = getInitialGrid(NO_ROWS, NO_COLS);\n    this.setState({grid});\n    this.state.algo.push(dijkstra);\n    this.state.algo.push(BFS);\n    this.state.algo.push(DFS);\n    this.state.algo.push(Astar);\n    this.state.algo.push(BestFS);\n\n    // const {algo} = this.props.location.state;\n    // console.log(algo);\n  }\n\n  handleMouseDown(row, col) {\n    if (!this.state.isRunning) {\n      const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({grid: newGrid, mouseIsPressed: true});\n    }\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.isRunning) {\n      if (!this.state.mouseIsPressed) return;\n      const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({grid: newGrid});\n    }\n  }\n\n  handleMouseUp() {\n    if (!this.state.isRunning) {\n      this.setState({mouseIsPressed: false});\n    }\n  }\n\n  animate(visitedNodesInOrder, nodesInShortestPathOrder) {\n    if (visitedNodesInOrder.length === null) return;\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 5 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        const newGrid = getVisitedGrid(this.state.grid, node.row, node.col);\n        this.setState({grid: newGrid});\n      }, 5 * i);\n    }\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        const newGrid = getShortestpathgrid(\n          this.state.grid,\n          node.row,\n          node.col\n        );\n        this.setState({grid: newGrid});\n      }, 50 * i);\n    }\n  }\n\n  visualize() {\n    if (!this.state.isRunning) {\n      const {algonum} = this.props.location.state;\n      console.log(algonum);\n      const {grid} = this.state;\n      this.setState({isRunning: true});\n      const startNode = grid[START_NODE_ROW][START_NODE_COL];\n      const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n      const visitedNodesInOrder = this.state.algo[algonum](\n        grid,\n        startNode,\n        finishNode\n      );\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\n    }\n  }\n\n  reset() {\n    const initgridd = getInitialGrid(NO_ROWS, NO_COLS);\n    this.setState({grid: initgridd});\n    this.setState({mouseIsPressed: false});\n    this.setState({isRunning: false});\n  }\n\n  render() {\n    const grid = this.state.grid;\n    const mouseIsPressed = this.state.mouseIsPressed;\n\n    return (\n      <div>\n        <Navbar />\n        <Rules />\n        <div className=\"h-100 row align-items-center\">\n          <div className=\"grid \">\n            {grid.map((row, rowIdx) => {\n              return (\n                <div key={rowIdx}>\n                  {row.map((node, nodeIdx) => {\n                    const {\n                      row,\n                      col,\n                      isFinish,\n                      isStart,\n                      isWall,\n                      isVisitednode,\n                      isShortestPath,\n                    } = node;\n                    return (\n                      <Node\n                        key={nodeIdx}\n                        col={col}\n                        isFinish={isFinish}\n                        isStart={isStart}\n                        isWall={isWall}\n                        mouseIsPressed={mouseIsPressed}\n                        isVisitednode={isVisitednode}\n                        isShortestPath={isShortestPath}\n                        onMouseDown={(row, col) =>\n                          this.handleMouseDown(row, col)\n                        }\n                        onMouseEnter={(row, col) =>\n                          this.handleMouseEnter(row, col)\n                        }\n                        onMouseUp={() => this.handleMouseUp()}\n                        row={row}></Node>\n                    );\n                  })}\n                </div>\n              );\n            })}\n          </div>\n        </div>\n        <button onClick={() => this.visualize()} className=\"b\">\n          Visualize\n        </button>\n        <button onClick={() => this.reset()}>Reset</button>\n      </div>\n    );\n  }\n}\n\nconst getInitialGrid = (x, y) => {\n  const grid = [];\n\n  for (let row = 0; row < x; row++) {\n    const currentRow = [];\n    for (let col = 0; col < y; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    hdistance: Infinity,\n    isVisitednode: false,\n    isShortestPath: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getVisitedGrid = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isVisitednode: true,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getShortestpathgrid = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isShortestPath: true,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n","import React, {Component} from \"react\";\r\nimport {Link, Route} from \"react-router-dom\";\r\nimport Navbar from \"./Navbar\";\r\n\r\nclass Code extends Component {\r\n  state = {};\r\n  render() {\r\n    const {algo} = this.props.location.state;\r\n    console.log(algo);\r\n\r\n    return (\r\n      <div>\r\n        <Navbar />\r\n        <div class=\"container\">\r\n          <pre class=\"pre-scrollable\">\r\n            <code>\r\n              <h1>Title One</h1>\r\n              <p>A line of sample text</p>\r\n              <p>Another line of sample text</p>\r\n              <p>Yet another line of sample text</p>\r\n\r\n              <p>A line of sample text</p>\r\n              <p>Another line of sample text</p>\r\n              <p>Yet another line of sample text</p>\r\n\r\n              <p>A line of sample text</p>\r\n              <p>Another line of sample text</p>\r\n              <p>Yet another line of sample text</p>\r\n\r\n              <p>A line of sample text</p>\r\n              <p>Another line of sample text</p>\r\n              <p>Yet another line of sample text</p>\r\n            </code>\r\n          </pre>\r\n        </div>\r\n\r\n        <Link\r\n          className=\"container\"\r\n          to={{\r\n            pathname: algo[2],\r\n            state: {\r\n              algonum: algo[1],\r\n            },\r\n          }}>\r\n          {algo[0]}\r\n        </Link>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Code;\r\n","import React, {Component} from \"react\";\r\n// import {Link} from \"react-router\";\r\nimport {Link, Route} from \"react-router-dom\";\r\nimport Code from \"./Code\";\r\n\r\nimport \"./Content.css\";\r\n\r\nclass Content extends Component {\r\n  render() {\r\n    console.log(this.props);\r\n\r\n    return (\r\n      <div className=\"card\">\r\n        <div className=\"card-body\">\r\n          <h5 className=\"card-title\">{this.props.title}</h5>\r\n          <p className=\"card-text\">List of Sorting algorithms</p>\r\n\r\n          <ol className=\"container-fluid  \">\r\n            {this.props.refs.map((tag) => (\r\n              <Link\r\n                className=\"btn btn-primary link\"\r\n                to={{\r\n                  pathname: \"/code\",\r\n                  state: {\r\n                    algo: tag,\r\n                  },\r\n                }}>\r\n                {tag[0]}\r\n              </Link>\r\n            ))}\r\n          </ol>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Content;\r\n","import React, {Component} from \"react\";\r\nimport Content from \"./Content\";\r\nimport Navbar from \"./Navbar\";\r\n\r\nclass Homepage extends Component {\r\n  state = {\r\n    tags: [\r\n      [\"BFS\", \"1\", \"/PathfindingVisualizer\"],\r\n      [\"Dijkstra\", \"0\", \"/PathfindingVisualizer\"],\r\n      [\"DFS (It doesn't garentee shortest path\", \"2\", \"/PathfindingVisualizer\"],\r\n      [\"Astar\", \"3\", \"/PathfindingVisualizer\"],\r\n      [\"BestFS\", \"4\", \"/PathfindingVisualizer\"],\r\n    ],\r\n\r\n    sortingalgos: [\r\n      [\"Merge\", \"0\", \"/Sorting\"],\r\n      [\"QuickSort\", \"1\", \"/Sorting\"],\r\n    ],\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <Navbar />\r\n        <Content\r\n          title={\"Sorting Path Finding\"}\r\n          refs={this.state.sortingalgos}\r\n        />\r\n        <Content title={\"Path Finding\"} refs={this.state.tags} />\r\n        {/* <Content title={\"Graph\"} refs={this.state.tags} /> */}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Homepage;\r\n","export function getMergeSortAnimations(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  const auxiliaryArray = array.slice();\n  mergeSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\n  return animations;\n}\n\nfunction mergeSortHelper(\n  mainArray,\n  startIdx,\n  endIdx,\n  auxiliaryArray,\n  animations,\n) {\n  if (startIdx === endIdx) return;\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\n  mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\n  mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\n  doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\n}\n\nfunction doMerge(\n  mainArray,\n  startIdx,\n  middleIdx,\n  endIdx,\n  auxiliaryArray,\n  animations,\n) {\n  let k = startIdx;\n  let i = startIdx;\n  let j = middleIdx + 1;\n  while (i <= middleIdx && j <= endIdx) {\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([i, j]);\n    // These are the values that we're comparing; we push them a second\n    // time to revert their color.\n    animations.push([i, j]);\n    if (auxiliaryArray[i] <= auxiliaryArray[j]) {\n      // We overwrite the value at index k in the original array with the\n      // value at index i in the auxiliary array.\n      animations.push([k, auxiliaryArray[i]]);\n      mainArray[k++] = auxiliaryArray[i++];\n    } else {\n      // We overwrite the value at index k in the original array with the\n      // value at index j in the auxiliary array.\n      animations.push([k, auxiliaryArray[j]]);\n      mainArray[k++] = auxiliaryArray[j++];\n    }\n  }\n  while (i <= middleIdx) {\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([i, i]);\n    // These are the values that we're comparing; we push them a second\n    // time to revert their color.\n    animations.push([i, i]);\n    // We overwrite the value at index k in the original array with the\n    // value at index i in the auxiliary array.\n    animations.push([k, auxiliaryArray[i]]);\n    mainArray[k++] = auxiliaryArray[i++];\n  }\n  while (j <= endIdx) {\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([j, j]);\n    // These are the values that we're comparing; we push them a second\n    // time to revert their color.\n    animations.push([j, j]);\n    // We overwrite the value at index k in the original array with the\n    // value at index j in the auxiliary array.\n    animations.push([k, auxiliaryArray[j]]);\n    mainArray[k++] = auxiliaryArray[j++];\n  }\n}\n","export function quickSort(array) {\r\n  const animations = [];\r\n  const low = 0;\r\n  const high = array.length - 1;\r\n  quickSorthelper(array, low, high, animations);\r\n  return animations;\r\n}\r\n\r\nexport function quickSorthelper(array, low, high, animations) {\r\n  if (low < high) {\r\n    /* pi is partitioning index, arr[pi] is now\r\n           at right place */\r\n    let pi = partition(array, low, high, animations);\r\n\r\n    quickSorthelper(array, low, pi - 1, animations); // Before pi\r\n    quickSorthelper(array, pi + 1, high, animations); // After pi\r\n  }\r\n}\r\n\r\nexport function partition(array, low, high, animations) {\r\n  // pivot (Element to be placed at right position)\r\n  let pivot = array[high];\r\n\r\n  let i = low - 1; // Index of smaller element\r\n\r\n  for (let j = low; j <= high - 1; j++) {\r\n    animations.push([j, high, 1]);\r\n    animations.push([j, high, 2]);\r\n    // If current element is smaller than the pivot\r\n    if (array[j] < pivot) {\r\n      i++; // increment index of smaller element\r\n\r\n      let k = array[j];\r\n      array[j] = array[i];\r\n      array[i] = k;\r\n      animations.push([i, j, 0]);\r\n      //swap arr[i] and arr[j]\r\n    }\r\n  }\r\n  animations.push([i + 1, high, 0]);\r\n  let k = array[high];\r\n  array[high] = array[i + 1];\r\n  array[i + 1] = k;\r\n  // swap arr[i + 1] and arr[high])\r\n  return i + 1;\r\n}\r\n","import React from \"react\";\nimport {getMergeSortAnimations} from \"../sortingAlgorithms/sortingAlgorithms.js\";\nimport \"./SortingVisualizer.css\";\nimport Navbar from \"../Pages//Navbar\";\nimport {quickSort} from \"../sortingAlgorithms/Quicksort\";\n\n// Change this value for the speed of the animations.\nconst ANIMATION_SPEED_MS = 1;\n\n// Change this value for the number of bars (value) in the array.\nconst NUMBER_OF_ARRAY_BARS = 300;\n\n// This is the main color of the array bars.\nconst PRIMARY_COLOR = \"turquoise\";\n\n// This is the color of array bars that are being compared throughout the animations.\nconst SECONDARY_COLOR = \"red\";\n\nexport default class SortingVisualizer extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      array: [],\n    };\n  }\n\n  componentDidMount() {\n    this.resetArray();\n  }\n\n  resetArray() {\n    const array = [];\n    for (let i = 0; i < NUMBER_OF_ARRAY_BARS; i++) {\n      array.push(randomIntFromInterval(5, 600));\n    }\n    this.setState({array});\n  }\n\n  sort() {\n    const {algonum} = this.props.location.state;\n    console.log(algonum);\n    if (algonum === \"0\") this.mergeSort();\n    else this.quickSort();\n  }\n\n  mergeSort() {\n    console.log(\"doing merge sort\");\n    const animations = getMergeSortAnimations(this.state.array);\n    for (let i = 0; i < animations.length; i++) {\n      const arrayBars = document.getElementsByClassName(\"array-bar\");\n      const isColorChange = i % 3 !== 2;\n      if (isColorChange) {\n        const [barOneIdx, barTwoIdx] = animations[i];\n        const barOneStyle = arrayBars[barOneIdx].style;\n        const barTwoStyle = arrayBars[barTwoIdx].style;\n        const color = i % 3 === 0 ? SECONDARY_COLOR : PRIMARY_COLOR;\n        setTimeout(() => {\n          barOneStyle.backgroundColor = color;\n          barTwoStyle.backgroundColor = color;\n        }, i * ANIMATION_SPEED_MS);\n      } else {\n        setTimeout(() => {\n          const [barOneIdx, newHeight] = animations[i];\n          const barOneStyle = arrayBars[barOneIdx].style;\n          barOneStyle.height = `${newHeight}px`;\n        }, i * ANIMATION_SPEED_MS);\n      }\n    }\n  }\n\n  quickSort() {\n    console.log(\"doing quick sort\");\n    console.log(this.state.array);\n    const animations = quickSort(this.state.array);\n    console.log(this.state.array);\n\n    console.log(animations);\n    for (let i = 0; i < animations.length; i++) {\n      const arrayBars = document.getElementsByClassName(\"array-bar\");\n      if (animations[i][2]) {\n        const [barOneIdx, barTwoIdx, x] = animations[i];\n        const barOneStyle = arrayBars[barOneIdx].style;\n        const barTwoStyle = arrayBars[barTwoIdx].style;\n        let color;\n\n        if (animations[i][2] == 1) color = SECONDARY_COLOR;\n        else color = PRIMARY_COLOR;\n        setTimeout(() => {\n          barOneStyle.backgroundColor = color;\n          barTwoStyle.backgroundColor = color;\n        }, i * ANIMATION_SPEED_MS);\n      } else {\n        setTimeout(() => {\n          const [barOneIdx, barTwoIdx, x] = animations[i];\n          const barOneStyle = arrayBars[barOneIdx].style;\n          const barTwoStyle = arrayBars[barTwoIdx].style;\n          const l = barOneStyle.height;\n          const r = barTwoStyle.height;\n\n          barOneStyle.height = `${r}`;\n          barTwoStyle.height = `${l}`;\n        }, i * ANIMATION_SPEED_MS);\n      }\n    }\n  }\n\n  heapSort() {\n    // We leave it as an exercise to the viewer of this code to implement this method.\n  }\n\n  bubbleSort() {\n    // We leave it as an exercise to the viewer of this code to implement this method.\n  }\n\n  // NOTE: This method will only work if your sorting algorithms actually return\n  // the sorted arrays; if they return the animations (as they currently do), then\n  // this method will be broken.\n  // testSortingAlgorithms() {\n  //   for (let i = 0; i < 100; i++) {\n  //     const array = [];\n  //     const length = randomIntFromInterval(1, 500);\n  //     for (let i = 0; i < length; i++) {\n  //       array.push(randomIntFromInterval(-500, 500));\n  //     }\n  //     const javaScriptSortedArray = array.slice().sort((a, b) => a - b);\n  //     const mergeSortedArray = getMergeSortAnimations(array.slice());\n  //     console.log(arraysAreEqual(javaScriptSortedArray, mergeSortedArray));\n  //   }\n  // }\n\n  render() {\n    const {array} = this.state;\n\n    return (\n      <div>\n        <Navbar />\n\n        <div className=\"array-container\">\n          {array.map((value, idx) => (\n            <div\n              className=\"array-bar\"\n              key={idx}\n              style={{\n                backgroundColor: PRIMARY_COLOR,\n                height: `${value}px`,\n              }}></div>\n          ))}\n\n          <button\n            className=\"btn btn-primary link1 \"\n            onClick={() => this.resetArray()}>\n            Generate New Array\n          </button>\n          <button\n            className=\"btn btn-primary link2 \"\n            onClick={() => this.sort()}>\n            Sort\n          </button>\n        </div>\n      </div>\n    );\n  }\n}\n\n// From https://stackoverflow.com/questions/4959975/generate-random-number-between-two-numbers-in-javascript\nfunction randomIntFromInterval(min, max) {\n  // min and max included\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\n// function arraysAreEqual(arrayOne, arrayTwo) {\n//   if (arrayOne.length !== arrayTwo.length) return false;\n//   for (let i = 0; i < arrayOne.length; i++) {\n//     if (arrayOne[i] !== arrayTwo[i]) {\n//       return false;\n//     }\n//   }\n//   return true;\n// }\n","import React from \"react\";\nimport \"./App.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\nimport Code from \"./Pages/Code\";\nimport Homepage from \"./Pages/Homepage\";\nimport {Route} from \"react-router-dom\";\nimport {HashRouter as Router} from \"react-router-dom\";\nimport SortingVisualizer from \"./SortingVisualizer/SortingVisualizer\";\nfunction App() {\n  return (\n    <Router basename=\"/\">\n      <Route path=\"/\" exact component={Homepage} />\n      <Route path=\"/PathfindingVisualizer\" component={PathfindingVisualizer} />\n      <Route path=\"/Code\" component={Code} />\n      <Route path=\"/Homepage\" component={Homepage} />\n      <Route path=\"/Sorting\" component={SortingVisualizer} />\n    </Router>\n    // <SortingVisualizer></SortingVisualizer>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport \"bootstrap/dist/css/bootstrap.css\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}